<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>GARBIDUP</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            touch-action: none;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
        }

        html,
        body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            background: #1a1a2e;
        }

        #container {
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
        }

        #gameWrapper {
            position: relative;
        }

        #threeCanvas,
        #uiCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        #threeCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        #uiCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: auto;
        }
    </style>
</head>

<body>
    <div id="container">
        <div id="gameWrapper">
            <canvas id="threeCanvas"></canvas>
            <canvas id="uiCanvas"></canvas>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@farcade/game-sdk@latest/dist/index.min.js"></script>
    <script>
        // Polyfill for roundRect if not available
        if (!CanvasRenderingContext2D.prototype.roundRect) {
            CanvasRenderingContext2D.prototype.roundRect = function (x, y, w, h, r) {
                if (w < 2 * r) r = w / 2;
                if (h < 2 * r) r = h / 2;
                this.moveTo(x + r, y);
                this.arcTo(x + w, y, x + w, y + h, r);
                this.arcTo(x + w, y + h, x, y + h, r);
                this.arcTo(x, y + h, x, y, r);
                this.arcTo(x, y, x + w, y, r);
                this.closePath();
                return this;
            };
        }

        // ============================================
        // CONFIGURATION
        // ============================================
        const CONFIG = {
            // Canvas dimensions will be set dynamically
            WIDTH: 400,
            HEIGHT: 600,

            // World dimensions (Three.js units) - elongated corridor
            CORRIDOR_WIDTH: 40,      // Narrower width
            WORLD_LENGTH: 200,       // Longer
            LAKE_Z: 100,             // Lake center position
            LAKE_WIDTH: 40,          // Lake width for balanced challenge

            // Gameplay
            LETTER_COUNT: 12,
            PILE_COUNT: 16,
            GRAVITY: 0.004,        // Lower gravity for longer, more dramatic arcs
            AIR_RESISTANCE: 0.998, // Less air resistance

            // Scoring
            POINTS_PER_LETTER: 100,
            SHOT_PENALTY: 50,
            PERFECT_BONUS: 200,

            // UI
            LETTER_SIZE: 30,       // Base size, will be calculated dynamically
            WORD_LETTER_SIZE: 38,  // Bigger letters for built word
            LETTER_GAP: 3,
            LETTER_Y: 70,          // Lower, leaving more room for score/dict at top
            WORD_Y: 120,           // Will be calculated dynamically
            ANIM_SPEED: 0.15,
        };

        // ============================================
        // OBJECT DICTIONARY
        // ============================================
        const DICTIONARY = {
            // 3-letter (weights 1-2)
            'CAN': { weight: 1 }, 'BAG': { weight: 1 }, 'JAR': { weight: 1 },
            'BOX': { weight: 1 }, 'MUG': { weight: 1 }, 'PAN': { weight: 2 },
            'CUP': { weight: 1 }, 'LID': { weight: 1 }, 'TOY': { weight: 1 },
            'RAG': { weight: 1 }, 'WIG': { weight: 1 }, 'HAT': { weight: 1 },
            'BRA': { weight: 1 }, 'EGG': { weight: 1 }, 'URN': { weight: 2 },

            // 4-letter (weights 2-3)
            'TIRE': { weight: 3 }, 'LAMP': { weight: 2 }, 'BOOK': { weight: 2 },
            'DRUM': { weight: 3 }, 'PIPE': { weight: 2 }, 'ROPE': { weight: 2 },
            'VASE': { weight: 2 }, 'TRAY': { weight: 2 }, 'BOWL': { weight: 2 },
            'CAGE': { weight: 2 }, 'SOCK': { weight: 1 }, 'BOOT': { weight: 2 },
            'FORK': { weight: 1 }, 'CLOG': { weight: 2 }, 'GONG': { weight: 3 },
            'BUST': { weight: 3 }, 'WAND': { weight: 1 }, 'TUBA': { weight: 4 },

            // 5-letter (weights 3-4)
            'CHAIR': { weight: 4 }, 'CRATE': { weight: 4 }, 'STOOL': { weight: 4 },
            'BRICK': { weight: 5 }, 'PLANT': { weight: 3 }, 'BOARD': { weight: 3 },
            'FRAME': { weight: 3 }, 'CLOCK': { weight: 3 }, 'RADIO': { weight: 3 },
            'TRUNK': { weight: 5 }, 'SPORK': { weight: 1 }, 'DECOY': { weight: 2 },
            'GNOME': { weight: 3 }, 'TIARA': { weight: 2 }, 'KEBAB': { weight: 1 },
            'SQUID': { weight: 2 }, 'BANJO': { weight: 3 }, 'CROCS': { weight: 2 },

            // 6-letter (weights 4-6)
            'BUCKET': { weight: 3 }, 'BARREL': { weight: 6 }, 'BOTTLE': { weight: 2 },
            'MIRROR': { weight: 4 }, 'CARPET': { weight: 5 }, 'FRIDGE': { weight: 8 },
            'DRAWER': { weight: 5 }, 'LADDER': { weight: 6 }, 'HEATER': { weight: 6 },
            'BASKET': { weight: 3 }, 'FEDORA': { weight: 2 }, 'TURBAN': { weight: 2 },
            'PIGEON': { weight: 2 }, 'CACTUS': { weight: 3 }, 'TURNIP': { weight: 2 },
            'WAFFLE': { weight: 1 }, 'DONUT': { weight: 1 }, 'SPONGE': { weight: 1 },
            'CANOE': { weight: 5 }, 'IGLOO': { weight: 7 }, 'ANCHOR': { weight: 8 },

            // 7-letter (weights 5-8)
            'BATHTUB': { weight: 8 }, 'BICYCLE': { weight: 7 }, 'MONITOR': { weight: 5 },
            'FREEZER': { weight: 8 }, 'TOASTER': { weight: 3 }, 'BLENDER': { weight: 4 },
            'PRINTER': { weight: 6 }, 'CURTAIN': { weight: 3 }, 'UKULELE': { weight: 2 },
            'SPATULA': { weight: 2 }, 'HAMMOCK': { weight: 4 }, 'PINATA': { weight: 2 },
            'TRICORN': { weight: 2 }, 'PELICAN': { weight: 3 }, 'COCONUT': { weight: 3 },
            'PANCAKE': { weight: 1 }, 'BAGPIPE': { weight: 4 }, 'COWBELL': { weight: 3 },

            // 8-letter bonus (weights 6-8)
            'TROMBONE': { weight: 5 }, 'SOMBRERO': { weight: 2 }, 'UNICYCLE': { weight: 6 },
            'DOORKNOB': { weight: 3 }, 'FLAMINGO': { weight: 3 }, 'ARMCHAIR': { weight: 7 },
            'FISHBOWL': { weight: 4 }, 'TRASHCAN': { weight: 4 }, 'BACKPACK': { weight: 4 },
        };

        const WORD_LIST = Object.keys(DICTIONARY);

        // ============================================
        // GAME STATE
        // ============================================
        let gameState = 'INTRO'; // Start with intro dialog
        let showDictionary = false;
        let dictScrollY = 0; // Scroll position for dictionary
        let animTime = 0; // Animation timer

        // Letters
        let letters = [];
        let selectedOrder = [];
        let letterAnimationQueue = []; // For intro animation
        let letterAnimationTimer = 0;

        // Pre-selected words for this round
        let preSelectedWords = [];

        // 3D objects
        let trashPiles = [];
        let currentObject = null;
        let objectMesh = null;
        let activePileIndex = -1;
        let pendingPileIndex = -1; // Preview of which pile will be used when word is submitted

        // Camera state
        let cameraMode = 'DUMPYARD'; // 'DUMPYARD' or 'GRASS'
        let targetCameraPos = new THREE.Vector3(0, 5, -10);
        let targetCameraLook = new THREE.Vector3(0, 0, 30);

        // Scoring
        let score = 0;
        let shotsTaken = 0;
        let pilesCleared = 0;

        // Messages
        let message = '';
        let messageTimer = 0;

        // Dialog system
        let dialogActive = false;
        let dialogLines = [];
        let currentDialogLine = 0;
        let currentDialogChar = 0;
        let dialogCharTimer = 0;
        let dialogPauseTimer = 0;
        const DIALOG_CHAR_SPEED = 30; // ms per character
        const DIALOG_PAUSE_TIME = 1000; // ms pause after line complete

        // Audio state (for future sound implementation)
        let isMuted = false;

        // Player name (from Remix SDK or default)
        let playerName = 'Newbie';

        // ============================================
        // REMIX SDK INTEGRATION
        // ============================================
        function isInRemix() {
            return window.FarcadeSDK && window.self !== window.top;
        }

        async function initRemixSDK() {
            if (!window.FarcadeSDK) return;

            try {
                // Signal ready and get game info (including player data)
                const gameInfo = await window.FarcadeSDK.singlePlayer.actions.ready();

                // Extract player name if available
                if (gameInfo && gameInfo.players && gameInfo.players.length > 0) {
                    const player = gameInfo.players[0];
                    if (player.name) {
                        playerName = player.name;
                    }
                }
            } catch (e) {
                // If ready() fails, just continue with default name
            }

            // Handle play again requests from Remix
            window.FarcadeSDK.on('play_again', () => {
                resetGame();
            });

            // Handle mute/unmute requests from Remix
            window.FarcadeSDK.on('toggle_mute', (data) => {
                isMuted = data.isMuted;
                // Future: apply mute to audio elements here
            });
        }

        function signalGameOver(finalScore) {
            if (!window.FarcadeSDK) return;
            window.FarcadeSDK.singlePlayer.actions.gameOver({ score: finalScore });
        }

        // Fling
        let flingStart = null;
        let flingCurrent = null;
        let isFlingReady = false;

        // Three.js
        let scene, camera, renderer;
        let uiCanvas, uiCtx;

        // Trail
        let trailPoints = [];
        let trailLine = null;

        // ============================================
        // THREE.JS SETUP
        // ============================================
        function initThree() {
            const threeCanvas = document.getElementById('threeCanvas');

            // Renderer - will be resized by handleResize
            renderer = new THREE.WebGLRenderer({ canvas: threeCanvas, antialias: true });
            renderer.setSize(CONFIG.WIDTH, CONFIG.HEIGHT);
            renderer.setClearColor(0x87CEEB);

            // Scene
            scene = new THREE.Scene();
            scene.fog = new THREE.Fog(0x87CEEB, 80, 200);

            // Camera - wider FOV to see more of the corridor
            camera = new THREE.PerspectiveCamera(70, CONFIG.WIDTH / CONFIG.HEIGHT, 0.1, 300);
            camera.position.set(0, 5, -10);
            camera.lookAt(0, 0, 50);

            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(10, 20, -10);
            scene.add(directionalLight);

            // Build environment
            buildEnvironment();

            // Handle resize
            handleResize();
            window.addEventListener('resize', handleResize);
        }

        function handleResize() {
            const container = document.getElementById('container');
            const wrapper = document.getElementById('gameWrapper');

            const containerW = container.clientWidth;
            const containerH = container.clientHeight;
            const targetRatio = 2 / 3;

            let width, height;

            if (containerW / containerH > targetRatio) {
                // Container is wider than 2:3, fit to height
                height = containerH;
                width = height * targetRatio;
            } else {
                // Container is taller than 2:3, fit to width
                width = containerW;
                height = width / targetRatio;
            }

            wrapper.style.width = width + 'px';
            wrapper.style.height = height + 'px';

            // Update internal resolution
            CONFIG.WIDTH = Math.floor(width);
            CONFIG.HEIGHT = Math.floor(height);

            // Update Three.js renderer
            if (renderer) {
                renderer.setSize(CONFIG.WIDTH, CONFIG.HEIGHT);
                camera.aspect = CONFIG.WIDTH / CONFIG.HEIGHT;
                camera.updateProjectionMatrix();
            }

            // Update UI canvas
            if (uiCanvas) {
                uiCanvas.width = CONFIG.WIDTH;
                uiCanvas.height = CONFIG.HEIGHT;
            }

            // Recalculate letter positions
            if (letters.length > 0) {
                // Calculate letter size to nearly fill screen width (with small margins)
                const margin = 16; // 8px on each side
                const availableWidth = CONFIG.WIDTH - margin;
                const letterSize = Math.floor((availableWidth - (CONFIG.LETTER_COUNT - 1) * CONFIG.LETTER_GAP) / CONFIG.LETTER_COUNT);
                CONFIG.LETTER_SIZE = letterSize;
                CONFIG.WORD_LETTER_SIZE = Math.floor(letterSize * 1.25); // Word letters 25% bigger
                CONFIG.WORD_Y = CONFIG.LETTER_Y + CONFIG.LETTER_SIZE + 18; // More gap

                const totalWidth = CONFIG.LETTER_COUNT * CONFIG.LETTER_SIZE + (CONFIG.LETTER_COUNT - 1) * CONFIG.LETTER_GAP;
                const startX = (CONFIG.WIDTH - totalWidth) / 2;

                letters.forEach((letter, i) => {
                    letter.poolX = startX + i * (CONFIG.LETTER_SIZE + CONFIG.LETTER_GAP);
                    letter.wordY = CONFIG.WORD_Y; // Update word Y position
                    if (!letter.selected) {
                        letter.currentX = letter.poolX;
                    }
                });

                updateWordPositions();
            }
        }

        function buildEnvironment() {
            const corridorWidth = CONFIG.CORRIDOR_WIDTH;
            const lakeZ = CONFIG.LAKE_Z;
            const lakeWidth = CONFIG.LAKE_WIDTH;
            const lakeStart = lakeZ - lakeWidth / 2;
            const lakeEnd = lakeZ + lakeWidth / 2;

            // Ground - Dumpyard (brown, from z=-10 to lake start)
            const dumpLength = lakeStart + 10;
            const dumpGeom = new THREE.BoxGeometry(corridorWidth, 1, dumpLength);
            const dumpMat = new THREE.MeshLambertMaterial({ color: 0x4a3728 });
            const dumpGround = new THREE.Mesh(dumpGeom, dumpMat);
            dumpGround.position.set(0, -0.5, (lakeStart - 10) / 2);
            scene.add(dumpGround);

            // Add some dirt texture variation with smaller boxes
            for (let i = 0; i < 40; i++) {
                const size = 2 + Math.random() * 4;
                const dirtGeom = new THREE.BoxGeometry(size, 0.3, size);
                const shade = 0x3a2718 + Math.floor(Math.random() * 0x101010);
                const dirtMat = new THREE.MeshLambertMaterial({ color: shade });
                const dirt = new THREE.Mesh(dirtGeom, dirtMat);
                dirt.position.set(
                    (Math.random() - 0.5) * (corridorWidth - 5),
                    0.01,
                    Math.random() * (lakeStart - 5)
                );
                scene.add(dirt);
            }

            // Lake (blue)
            const lakeGeom = new THREE.BoxGeometry(corridorWidth, 0.5, lakeWidth);
            const lakeMat = new THREE.MeshLambertMaterial({ color: 0x2e86ab });
            const lake = new THREE.Mesh(lakeGeom, lakeMat);
            lake.position.set(0, -0.3, lakeZ);
            scene.add(lake);

            // Lake surface shimmer
            const shimmerGeom = new THREE.PlaneGeometry(corridorWidth - 10, lakeWidth - 10);
            const shimmerMat = new THREE.MeshBasicMaterial({
                color: 0xffffff,
                transparent: true,
                opacity: 0.15
            });
            const shimmer = new THREE.Mesh(shimmerGeom, shimmerMat);
            shimmer.rotation.x = -Math.PI / 2;
            shimmer.position.set(0, 0.01, lakeZ);
            scene.add(shimmer);

            // Grass (green, from lake end onwards)
            const grassLength = 80;
            const grassGeom = new THREE.BoxGeometry(corridorWidth, 1, grassLength);
            const grassMat = new THREE.MeshLambertMaterial({ color: 0x3d7a2d });
            const grass = new THREE.Mesh(grassGeom, grassMat);
            grass.position.set(0, -0.5, lakeEnd + grassLength / 2);
            scene.add(grass);

            // Some grass tufts
            for (let i = 0; i < 30; i++) {
                const tuftGeom = new THREE.BoxGeometry(0.5, 1 + Math.random(), 0.5);
                const tuftMat = new THREE.MeshLambertMaterial({ color: 0x228B22 });
                const tuft = new THREE.Mesh(tuftGeom, tuftMat);
                tuft.position.set(
                    (Math.random() - 0.5) * (corridorWidth - 5),
                    0.5,
                    lakeEnd + 5 + Math.random() * (grassLength - 10)
                );
                scene.add(tuft);
            }

            // Distant trees (simple boxes) - at the far end
            for (let i = 0; i < 8; i++) {
                // Trunk
                const trunkGeom = new THREE.BoxGeometry(1, 4, 1);
                const trunkMat = new THREE.MeshLambertMaterial({ color: 0x4a3020 });
                const trunk = new THREE.Mesh(trunkGeom, trunkMat);
                trunk.position.set(
                    (Math.random() - 0.5) * (corridorWidth - 5),
                    2,
                    lakeEnd + grassLength - 20 + Math.random() * 15
                );
                scene.add(trunk);

                // Foliage
                const foliageGeom = new THREE.BoxGeometry(3, 5, 3);
                const foliageMat = new THREE.MeshLambertMaterial({ color: 0x1a5a1a });
                const foliage = new THREE.Mesh(foliageGeom, foliageMat);
                foliage.position.set(trunk.position.x, 6, trunk.position.z);
                scene.add(foliage);
            }

            // Side walls/barriers (to make it feel like a corridor)
            const wallHeight = 3;
            const wallMat = new THREE.MeshLambertMaterial({ color: 0x5a4a3a });

            // Left wall
            const leftWallGeom = new THREE.BoxGeometry(2, wallHeight, CONFIG.WORLD_LENGTH);
            const leftWall = new THREE.Mesh(leftWallGeom, wallMat);
            leftWall.position.set(-corridorWidth / 2 - 1, wallHeight / 2, CONFIG.WORLD_LENGTH / 2 - 20);
            scene.add(leftWall);

            // Right wall
            const rightWall = new THREE.Mesh(leftWallGeom, wallMat);
            rightWall.position.set(corridorWidth / 2 + 1, wallHeight / 2, CONFIG.WORLD_LENGTH / 2 - 20);
            scene.add(rightWall);

            // Trail line (hidden for now - will be replaced with sprite effects later)
            // const trailMat = new THREE.LineBasicMaterial({ color: 0xffcc00, linewidth: 2 });
            // const trailGeom = new THREE.BufferGeometry();
            // trailLine = new THREE.Line(trailGeom, trailMat);
            // scene.add(trailLine);
            trailLine = null;
        }

        function createTrashPiles() {
            // Remove old piles
            trashPiles.forEach(pile => {
                if (pile.mesh) scene.remove(pile.mesh);
            });
            trashPiles = [];

            const lakeStart = CONFIG.LAKE_Z - CONFIG.LAKE_WIDTH / 2;
            const maxX = (CONFIG.CORRIDOR_WIDTH / 2) - 5;

            for (let i = 0; i < CONFIG.PILE_COUNT; i++) {
                // Spread piles along the dumpyard (from z=5 to just before lake)
                const z = 5 + (i / CONFIG.PILE_COUNT) * (lakeStart - 15);
                const x = (Math.random() - 0.5) * maxX * 2;

                // Create pile mesh (irregular stack of boxes)
                const pileGroup = new THREE.Group();

                const baseSize = 1.5 + Math.random();
                for (let j = 0; j < 3 + Math.floor(Math.random() * 3); j++) {
                    const boxSize = baseSize * (1 - j * 0.2);
                    const boxGeom = new THREE.BoxGeometry(
                        boxSize + Math.random() * 0.5,
                        boxSize * 0.6,
                        boxSize + Math.random() * 0.5
                    );
                    const shade = 0x3a2a1a + Math.floor(Math.random() * 0x151515);
                    const boxMat = new THREE.MeshLambertMaterial({ color: shade });
                    const box = new THREE.Mesh(boxGeom, boxMat);
                    box.position.set(
                        (Math.random() - 0.5) * 0.5,
                        j * boxSize * 0.5 + boxSize * 0.3,
                        (Math.random() - 0.5) * 0.5
                    );
                    box.rotation.y = Math.random() * 0.5;
                    pileGroup.add(box);
                }

                pileGroup.position.set(x, 0, z);
                scene.add(pileGroup);

                trashPiles.push({
                    x: x,
                    z: z,
                    mesh: pileGroup,
                    active: true
                });
            }
        }

        function createObjectMesh(word, weight) {
            // Remove old object
            if (objectMesh) {
                scene.remove(objectMesh);
            }

            // Create irregular triangular prism
            const size = 0.8 + weight * 0.1;
            const shape = new THREE.Shape();
            shape.moveTo(-size, -size * 0.5);
            shape.lineTo(size * 0.6, -size * 0.3);
            shape.lineTo(size * 0.3, size);
            shape.closePath();

            const extrudeSettings = { depth: size * 0.5, bevelEnabled: false };
            const geom = new THREE.ExtrudeGeometry(shape, extrudeSettings);

            // Color based on weight
            const hue = (50 - weight * 4) / 360;
            const color = new THREE.Color().setHSL(hue, 0.7, 0.5);
            const mat = new THREE.MeshLambertMaterial({ color: color });

            objectMesh = new THREE.Mesh(geom, mat);
            objectMesh.castShadow = true;

            // Add outline
            const edges = new THREE.EdgesGeometry(geom);
            const lineMat = new THREE.LineBasicMaterial({ color: 0x222222 });
            const outline = new THREE.LineSegments(edges, lineMat);
            objectMesh.add(outline);

            scene.add(objectMesh);

            return objectMesh;
        }

        function updateTrail() {
            // Trail disabled for now
        }

        // ============================================
        // UI CANVAS SETUP
        // ============================================
        function initUI() {
            uiCanvas = document.getElementById('uiCanvas');
            uiCtx = uiCanvas.getContext('2d');
            uiCanvas.width = CONFIG.WIDTH;
            uiCanvas.height = CONFIG.HEIGHT;
        }

        // ============================================
        // LETTER GENERATION
        // ============================================
        function canFormWord(word, availableLetters) {
            const letterCounts = {};
            availableLetters.forEach(c => letterCounts[c] = (letterCounts[c] || 0) + 1);

            for (const c of word) {
                if (!letterCounts[c] || letterCounts[c] <= 0) return false;
                letterCounts[c]--;
            }
            return true;
        }

        function getRequiredLetters(words) {
            // Get minimum letters needed to form all words
            const maxCounts = {};
            for (const word of words) {
                const counts = {};
                for (const c of word) {
                    counts[c] = (counts[c] || 0) + 1;
                }
                for (const [c, count] of Object.entries(counts)) {
                    maxCounts[c] = Math.max(maxCounts[c] || 0, count);
                }
            }

            let letters = [];
            for (const [c, count] of Object.entries(maxCounts)) {
                for (let i = 0; i < count; i++) {
                    letters.push(c);
                }
            }
            return letters;
        }

        function generateLetterPool() {
            // Strategy: Pick 16 words that share letters efficiently
            // Prioritize shorter words first since they share letters better

            let bestWords = [];
            let bestLetters = [];

            for (let attempt = 0; attempt < 100; attempt++) {
                // Sort by length first (shorter words share letters better), then shuffle within groups
                const byLength = {};
                for (const word of WORD_LIST) {
                    const len = word.length;
                    if (!byLength[len]) byLength[len] = [];
                    byLength[len].push(word);
                }

                // Shuffle each length group
                for (const len of Object.keys(byLength)) {
                    byLength[len].sort(() => Math.random() - 0.5);
                }

                // Build word list: 3-letter first, then 4, 5, etc (but shuffle order of lengths sometimes)
                const lengths = Object.keys(byLength).map(Number).sort((a, b) => a - b);
                if (Math.random() < 0.3) {
                    // Sometimes try mixing it up
                    lengths.sort(() => Math.random() - 0.5);
                }

                const shuffled = [];
                for (const len of lengths) {
                    shuffled.push(...byLength[len]);
                }

                const candidateWords = [];
                let candidateLetters = [];

                for (const word of shuffled) {
                    if (candidateWords.length >= CONFIG.PILE_COUNT) break;

                    // Skip if we already have this word
                    if (candidateWords.includes(word)) continue;

                    // Check if adding this word would require too many letters
                    const testWords = [...candidateWords, word];
                    const required = getRequiredLetters(testWords);

                    if (required.length <= CONFIG.LETTER_COUNT) {
                        candidateWords.push(word);
                        candidateLetters = required;
                    }
                }

                if (candidateWords.length >= CONFIG.PILE_COUNT) {
                    bestWords = candidateWords;
                    bestLetters = candidateLetters;
                    break;
                }

                // Keep best attempt so far
                if (candidateWords.length > bestWords.length) {
                    bestWords = candidateWords;
                    bestLetters = candidateLetters;
                }
            }

            // Store the 16 pre-selected words for this game (sorted alphabetically for display)
            preSelectedWords = bestWords.slice(0, CONFIG.PILE_COUNT).sort((a, b) => a.localeCompare(b));

            // Start with required letters
            let chars = [...bestLetters];

            // Pad to 12 letters with useful letters
            const vowels = 'EEEEAAAIIIOOU';
            const consonants = 'TTNNSSRRHHLLDDCCMMBBPPFFGGWW';
            const letterCount = {};
            chars.forEach(c => letterCount[c] = (letterCount[c] || 0) + 1);

            while (chars.length < CONFIG.LETTER_COUNT) {
                const vowelCount = chars.filter(c => 'AEIOU'.includes(c)).length;
                const pool = vowelCount < 4 ? vowels : consonants;
                const letter = pool[Math.floor(Math.random() * pool.length)];

                if ((letterCount[letter] || 0) < 3) {
                    chars.push(letter);
                    letterCount[letter] = (letterCount[letter] || 0) + 1;
                }
            }

            // Shuffle the letters
            for (let i = chars.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [chars[i], chars[j]] = [chars[j], chars[i]];
            }

            // Calculate letter sizes to fill screen
            const margin = 16;
            const availableWidth = CONFIG.WIDTH - margin;
            CONFIG.LETTER_SIZE = Math.floor((availableWidth - (CONFIG.LETTER_COUNT - 1) * CONFIG.LETTER_GAP) / CONFIG.LETTER_COUNT);
            CONFIG.WORD_LETTER_SIZE = Math.floor(CONFIG.LETTER_SIZE * 1.25);
            CONFIG.WORD_Y = CONFIG.LETTER_Y + CONFIG.LETTER_SIZE + 18;

            const totalWidth = CONFIG.LETTER_COUNT * CONFIG.LETTER_SIZE + (CONFIG.LETTER_COUNT - 1) * CONFIG.LETTER_GAP;
            const startX = (CONFIG.WIDTH - totalWidth) / 2;

            // Create letters - start at bottom center (tiny) for intro animation
            const centerX = CONFIG.WIDTH / 2;
            const bottomY = CONFIG.HEIGHT + 20;

            letters = chars.map((char, i) => ({
                char: char,
                poolX: startX + i * (CONFIG.LETTER_SIZE + CONFIG.LETTER_GAP),
                poolY: CONFIG.LETTER_Y,
                wordX: 0,
                wordY: CONFIG.WORD_Y,
                currentX: centerX,
                currentY: bottomY,
                currentSize: 5,
                targetSize: CONFIG.LETTER_SIZE,
                selected: false,
                animating: true,
                revealed: false
            }));

            selectedOrder = [];

            // Setup animation queue
            letterAnimationQueue = [];
            for (let i = 0; i < letters.length; i++) {
                letterAnimationQueue.push(i);
            }
            letterAnimationTimer = 0;
        }

        function getSelectedWord() {
            return selectedOrder.map(i => letters[i].char).join('');
        }

        function isValidWord(word) {
            return DICTIONARY.hasOwnProperty(word);
        }

        function updateWordPositions() {
            const count = selectedOrder.length;
            if (count === 0) return;

            const wordLetterSize = CONFIG.WORD_LETTER_SIZE;
            const totalWidth = count * wordLetterSize + (count - 1) * CONFIG.LETTER_GAP;
            const startX = (CONFIG.WIDTH - totalWidth) / 2;

            selectedOrder.forEach((letterIndex, orderIndex) => {
                letters[letterIndex].wordX = startX + orderIndex * (wordLetterSize + CONFIG.LETTER_GAP);
            });
        }

        function selectLetter(index) {
            if (letters[index].selected) return;
            letters[index].selected = true;
            letters[index].animating = true;
            selectedOrder.push(index);
            updateWordPositions();
            updatePendingPile();
        }

        function deselectLetter(index) {
            const orderPos = selectedOrder.indexOf(index);
            if (orderPos === -1) return;

            // Only deselect the clicked letter
            letters[index].selected = false;
            letters[index].animating = true;

            // Remove from selectedOrder
            selectedOrder.splice(orderPos, 1);

            updateWordPositions();
            updatePendingPile();
        }

        function updatePendingPile() {
            const word = getSelectedWord();

            if (isValidWord(word)) {
                // Find an active pile to preview
                const activePiles = trashPiles.map((p, i) => ({ pile: p, index: i })).filter(p => p.pile.active);
                if (activePiles.length > 0) {
                    // Use a deterministic selection based on word (so it doesn't change while typing)
                    const hash = word.split('').reduce((acc, c) => acc + c.charCodeAt(0), 0);
                    const chosen = activePiles[hash % activePiles.length];
                    pendingPileIndex = chosen.index;

                    // Move camera to show the pending pile
                    const pile = trashPiles[pendingPileIndex];
                    targetCameraPos.set(pile.x, 6, pile.z - 15);
                    targetCameraLook.set(pile.x, 2, pile.z + 30);
                }
            } else {
                // No valid word - reset to default view
                pendingPileIndex = -1;
                targetCameraPos.set(0, 5, -10);
                targetCameraLook.set(0, 0, 50);
            }
        }

        // ============================================
        // UI RENDERING
        // ============================================
        function renderUI() {
            uiCtx.clearRect(0, 0, CONFIG.WIDTH, CONFIG.HEIGHT);

            // Increment animation time
            animTime += 0.05;

            // Score at top of sky
            renderTopScore();

            renderLetterPool();
            renderWordArea();
            renderBottomUI();

            // Message
            if (messageTimer > 0) {
                const msgPadding = Math.floor(CONFIG.WIDTH * 0.125);
                const msgHeight = Math.floor(CONFIG.HEIGHT * 0.1);
                const msgFontSize = Math.max(14, Math.floor(CONFIG.WIDTH * 0.055));
                uiCtx.fillStyle = 'rgba(0,0,0,0.7)';
                uiCtx.fillRect(msgPadding, CONFIG.HEIGHT / 2 - msgHeight / 2, CONFIG.WIDTH - msgPadding * 2, msgHeight);
                uiCtx.fillStyle = '#FFF';
                uiCtx.font = `bold ${msgFontSize}px Arial`;
                uiCtx.textAlign = 'center';
                uiCtx.fillText(message, CONFIG.WIDTH / 2, CONFIG.HEIGHT / 2 + msgFontSize * 0.35);
            }

            // Fling indicator
            if (gameState === 'FLING' && flingStart && flingCurrent) {
                renderFlingIndicator();
            }

            if (showDictionary) {
                renderDictionaryPopup();
            }

            if (gameState === 'VICTORY') {
                renderVictoryScreen();
            }
        }

        function renderTopScore() {
            // Proportional positioning
            const topY = Math.floor(CONFIG.HEIGHT * 0.053);
            const scoreFontSize = Math.max(20, Math.floor(CONFIG.WIDTH * 0.105));
            const scoreX = Math.floor(CONFIG.WIDTH * 0.03);

            // Score on left with wave animation on digits
            const scoreStr = score.toString();
            uiCtx.font = `bold ${scoreFontSize}px Arial`;
            uiCtx.textAlign = 'left';
            uiCtx.textBaseline = 'middle';

            let xPos = scoreX;
            for (let i = 0; i < scoreStr.length; i++) {
                const digit = scoreStr[i];
                const waveOffset = Math.sin(animTime * 0.5 + i * 1.2) * 3;

                // Thicker shadow/outline effect
                uiCtx.fillStyle = 'rgba(0,0,0,0.6)';
                uiCtx.fillText(digit, xPos + 3, topY + waveOffset + 3);
                uiCtx.fillText(digit, xPos + 2, topY + waveOffset + 2);

                // Gold text
                uiCtx.fillStyle = '#FFD700';
                uiCtx.fillText(digit, xPos, topY + waveOffset);

                xPos += uiCtx.measureText(digit).width + 2;
            }

            // Dictionary button on right - proportional to screen width
            const btnWidth = Math.floor(CONFIG.WIDTH * 0.325);
            const btnHeight = Math.floor(CONFIG.HEIGHT * 0.067);
            const btnX = CONFIG.WIDTH - btnWidth - Math.floor(CONFIG.WIDTH * 0.025);
            const btnY = Math.floor(CONFIG.HEIGHT * 0.02);
            const cornerRadius = Math.floor(btnHeight * 0.2);
            const btnFontSize = Math.max(12, Math.floor(btnHeight * 0.45));

            if (showDictionary) {
                // Glowing effect when dictionary is open
                const glowIntensity = 0.4 + Math.sin(animTime * 2) * 0.2;
                uiCtx.shadowColor = `rgba(100, 200, 255, ${glowIntensity})`;
                uiCtx.shadowBlur = 15;

                // Shadow
                uiCtx.fillStyle = 'rgba(0,0,0,0.4)';
                uiCtx.beginPath();
                uiCtx.roundRect(btnX + 2, btnY + 2, btnWidth, btnHeight, cornerRadius);
                uiCtx.fill();

                // Active state - brighter blue
                uiCtx.fillStyle = '#4a90d9';
                uiCtx.beginPath();
                uiCtx.roundRect(btnX, btnY, btnWidth, btnHeight, cornerRadius);
                uiCtx.fill();

                uiCtx.strokeStyle = '#6ab0f9';
                uiCtx.lineWidth = 2;
                uiCtx.beginPath();
                uiCtx.roundRect(btnX, btnY, btnWidth, btnHeight, cornerRadius);
                uiCtx.stroke();

                // Reset shadow
                uiCtx.shadowColor = 'transparent';
                uiCtx.shadowBlur = 0;
            } else {
                // Normal state
                uiCtx.fillStyle = 'rgba(0,0,0,0.4)';
                uiCtx.beginPath();
                uiCtx.roundRect(btnX + 2, btnY + 2, btnWidth, btnHeight, cornerRadius);
                uiCtx.fill();

                uiCtx.fillStyle = '#555';
                uiCtx.beginPath();
                uiCtx.roundRect(btnX, btnY, btnWidth, btnHeight, cornerRadius);
                uiCtx.fill();

                uiCtx.strokeStyle = '#888';
                uiCtx.lineWidth = 2;
                uiCtx.beginPath();
                uiCtx.roundRect(btnX, btnY, btnWidth, btnHeight, cornerRadius);
                uiCtx.stroke();
            }

            uiCtx.fillStyle = '#FFF';
            uiCtx.font = `bold ${btnFontSize}px Arial`;
            uiCtx.textAlign = 'center';
            uiCtx.textBaseline = 'middle';
            uiCtx.fillText('DICTIONARY', btnX + btnWidth / 2, btnY + btnHeight / 2);
        }

        function renderLetterPool() {
            for (let i = 0; i < letters.length; i++) {
                const letter = letters[i];
                if (letter.selected) continue;
                if (!letter.revealed) continue; // Don't render unrevealed letters

                const size = letter.currentSize || CONFIG.LETTER_SIZE;
                const fontSize = Math.floor(size * 0.6);

                const x = letter.currentX;
                const y = letter.currentY;

                // Shadow for depth
                uiCtx.fillStyle = 'rgba(0, 0, 0, 0.4)';
                uiCtx.fillRect(x + 2, y + 2, size, size);

                // Box
                uiCtx.fillStyle = '#4a90d9';
                uiCtx.fillRect(x, y, size, size);

                uiCtx.strokeStyle = '#2a5a89';
                uiCtx.lineWidth = 2;
                uiCtx.strokeRect(x, y, size, size);

                // Letter with shadow
                uiCtx.font = `bold ${fontSize}px Arial`;
                uiCtx.textAlign = 'center';
                uiCtx.textBaseline = 'middle';

                uiCtx.fillStyle = 'rgba(0,0,0,0.3)';
                uiCtx.fillText(letter.char, x + size / 2 + 1, y + size / 2 + 1);

                uiCtx.fillStyle = '#FFF';
                uiCtx.fillText(letter.char, x + size / 2, y + size / 2);
            }
        }

        function renderWordArea() {
            const word = getSelectedWord();
            const isValid = isValidWord(word);
            const size = CONFIG.WORD_LETTER_SIZE;
            const fontSize = Math.floor(size * 0.6);

            for (let orderIndex = 0; orderIndex < selectedOrder.length; orderIndex++) {
                const letterIndex = selectedOrder[orderIndex];
                const letter = letters[letterIndex];

                const x = letter.currentX;
                const y = letter.currentY;

                // Shadow for depth
                uiCtx.fillStyle = 'rgba(0, 0, 0, 0.4)';
                uiCtx.fillRect(x + 2, y + 2, size, size);

                // Box
                uiCtx.fillStyle = isValid ? '#3d8a3d' : '#5a5a6a';
                uiCtx.fillRect(x, y, size, size);
                uiCtx.strokeStyle = isValid ? '#2d6a2d' : '#3a3a4a';
                uiCtx.lineWidth = 2;
                uiCtx.strokeRect(x, y, size, size);

                // Letter with shadow
                uiCtx.font = `bold ${fontSize}px Arial`;
                uiCtx.textAlign = 'center';
                uiCtx.textBaseline = 'middle';

                uiCtx.fillStyle = 'rgba(0,0,0,0.3)';
                uiCtx.fillText(letter.char, x + size / 2 + 1, y + size / 2 + 1);

                uiCtx.fillStyle = '#FFF';
                uiCtx.fillText(letter.char, x + size / 2, y + size / 2);
            }

            if (isValid && gameState === 'WORD_BUILDING') {
                // Button size proportional to screen width
                const baseBtnWidth = Math.floor(CONFIG.WIDTH * 0.4); // 40% of width
                const baseBtnHeight = Math.floor(baseBtnWidth * 0.3125); // Maintain aspect ratio
                const btnGap = Math.floor(CONFIG.HEIGHT * 0.03); // Gap below word letters
                const cornerRadius = Math.floor(baseBtnHeight * 0.2);

                // Pulsing animation - slower (half speed)
                const pulseScale = 1 + Math.sin(animTime * 2) * 0.03;
                const btnWidth = baseBtnWidth * pulseScale;
                const btnHeight = baseBtnHeight * pulseScale;
                const btnX = (CONFIG.WIDTH - btnWidth) / 2;
                const btnY = CONFIG.WORD_Y + size + btnGap - (btnHeight - baseBtnHeight) / 2;

                // Glow effect - subtler
                const glowIntensity = 0.2 + Math.sin(animTime * 2) * 0.1;
                uiCtx.shadowColor = `rgba(76, 175, 80, ${glowIntensity})`;
                uiCtx.shadowBlur = Math.floor(baseBtnHeight * 0.24) + Math.sin(animTime * 2) * 4;

                // Button shadow
                uiCtx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                uiCtx.beginPath();
                uiCtx.roundRect(btnX + 3, btnY + 3, btnWidth, btnHeight, cornerRadius);
                uiCtx.fill();

                // Button gradient
                const gradient = uiCtx.createLinearGradient(btnX, btnY, btnX, btnY + btnHeight);
                gradient.addColorStop(0, '#5CBF60');
                gradient.addColorStop(0.5, '#4CAF50');
                gradient.addColorStop(1, '#3D8B40');
                uiCtx.fillStyle = gradient;
                uiCtx.beginPath();
                uiCtx.roundRect(btnX, btnY, btnWidth, btnHeight, cornerRadius);
                uiCtx.fill();

                // Reset shadow
                uiCtx.shadowColor = 'transparent';
                uiCtx.shadowBlur = 0;

                // Border
                uiCtx.strokeStyle = '#2d7a2d';
                uiCtx.lineWidth = Math.max(2, Math.floor(baseBtnHeight * 0.06));
                uiCtx.beginPath();
                uiCtx.roundRect(btnX, btnY, btnWidth, btnHeight, cornerRadius);
                uiCtx.stroke();

                // Highlight
                uiCtx.fillStyle = 'rgba(255,255,255,0.2)';
                uiCtx.beginPath();
                uiCtx.roundRect(btnX + 4, btnY + 4, btnWidth - 8, btnHeight / 2 - 4, Math.max(2, cornerRadius - 4));
                uiCtx.fill();

                // Text - proportional to button
                const baseFontSize = Math.floor(baseBtnHeight * 0.44);
                const fontSize = Math.floor(baseFontSize * pulseScale);
                uiCtx.font = `bold ${fontSize}px Arial`;
                uiCtx.textAlign = 'center';
                uiCtx.textBaseline = 'middle';
                uiCtx.fillStyle = 'rgba(0,0,0,0.3)';
                uiCtx.fillText('THROW IT!', CONFIG.WIDTH / 2 + 1, btnY + btnHeight / 2 + 1);
                uiCtx.fillStyle = '#FFF';
                uiCtx.fillText('THROW IT!', CONFIG.WIDTH / 2, btnY + btnHeight / 2);
            }
        }

        function renderBottomUI() {
            // Show dialog box instead of tidiness when dialog is active
            if (dialogActive) {
                renderDialogBox();
                return;
            }

            const pilesCleared = CONFIG.PILE_COUNT - trashPiles.filter(p => p.active).length;

            // Calculate square size to fit available width (like letters do)
            const margin = 40; // 20px on each side
            const availableWidth = CONFIG.WIDTH - margin;
            const squareGap = Math.max(2, Math.floor(CONFIG.WIDTH / 100)); // Scale gap with width
            const squareSize = Math.floor((availableWidth - (CONFIG.PILE_COUNT - 1) * squareGap) / CONFIG.PILE_COUNT);

            const totalWidth = CONFIG.PILE_COUNT * squareSize + (CONFIG.PILE_COUNT - 1) * squareGap;
            const startX = (CONFIG.WIDTH - totalWidth) / 2;
            const squareY = CONFIG.HEIGHT - squareSize - 20;

            // Font size proportional to square size
            const labelFontSize = Math.max(12, Math.floor(squareSize * 0.9));

            // "TIDINESS" label - left aligned above progress bar
            uiCtx.font = `bold ${labelFontSize}px Arial`;
            uiCtx.textAlign = 'left';
            uiCtx.textBaseline = 'middle';
            uiCtx.fillStyle = 'rgba(0,0,0,0.5)';
            uiCtx.fillText('TIDINESS', startX + 1, squareY - squareSize * 0.7 + 1);
            uiCtx.fillStyle = '#CCC';
            uiCtx.fillText('TIDINESS', startX, squareY - squareSize * 0.7);

            // "WEIGHT X" label - right aligned at same level as TIDINESS
            let displayWeight = null;
            if (currentObject && currentObject.weight) {
                displayWeight = currentObject.weight;
            } else if (gameState === 'WORD_BUILDING') {
                const word = getSelectedWord();
                if (isValidWord(word)) {
                    displayWeight = DICTIONARY[word].weight;
                }
            }

            if (displayWeight !== null) {
                const endX = startX + totalWidth;
                const weightText = 'WEIGHT ' + displayWeight;
                uiCtx.font = `bold ${labelFontSize}px Arial`;
                uiCtx.textAlign = 'right';
                uiCtx.textBaseline = 'middle';
                uiCtx.fillStyle = 'rgba(0,0,0,0.5)';
                uiCtx.fillText(weightText, endX + 1, squareY - squareSize * 0.7 + 1);
                uiCtx.fillStyle = '#CCC';
                uiCtx.fillText(weightText, endX, squareY - squareSize * 0.7);
            }

            const cornerRadius = Math.max(2, Math.floor(squareSize / 4));

            for (let i = 0; i < CONFIG.PILE_COUNT; i++) {
                const x = startX + i * (squareSize + squareGap);
                const isFilled = i < pilesCleared;

                // Shadow
                uiCtx.fillStyle = 'rgba(0,0,0,0.3)';
                uiCtx.beginPath();
                uiCtx.roundRect(x + 2, squareY + 2, squareSize, squareSize, cornerRadius);
                uiCtx.fill();

                if (isFilled) {
                    const hue = 120 + Math.sin(animTime * 0.5 + i * 0.15) * 10;
                    const lightness = 50 + Math.sin(animTime * 0.7 + i * 0.2) * 5;
                    uiCtx.fillStyle = `hsl(${hue}, 60%, ${lightness}%)`;
                } else {
                    uiCtx.fillStyle = 'rgba(60, 60, 60, 0.8)';
                }

                uiCtx.beginPath();
                uiCtx.roundRect(x, squareY, squareSize, squareSize, cornerRadius);
                uiCtx.fill();

                if (isFilled) {
                    uiCtx.fillStyle = 'rgba(255,255,255,0.2)';
                    uiCtx.beginPath();
                    uiCtx.roundRect(x + 3, squareY + 3, squareSize - 6, squareSize / 2 - 2, Math.max(1, cornerRadius - 2));
                    uiCtx.fill();
                }
            }
        }

        function renderDialogBox() {
            // Scale dialog box proportionally to screen size
            const boxHeight = Math.floor(CONFIG.HEIGHT * 0.12); // 12% of height
            const boxMargin = Math.floor(CONFIG.WIDTH * 0.025); // 2.5% margin
            const boxY = CONFIG.HEIGHT - boxHeight - boxMargin;
            const boxX = boxMargin;
            const boxWidth = CONFIG.WIDTH - boxMargin * 2;
            const cornerRadius = Math.floor(boxHeight * 0.14);

            // Box background
            uiCtx.fillStyle = 'rgba(20, 30, 40, 0.95)';
            uiCtx.beginPath();
            uiCtx.roundRect(boxX, boxY, boxWidth, boxHeight, cornerRadius);
            uiCtx.fill();

            // Box border
            uiCtx.strokeStyle = 'rgba(100, 140, 180, 0.6)';
            uiCtx.lineWidth = 2;
            uiCtx.beginPath();
            uiCtx.roundRect(boxX, boxY, boxWidth, boxHeight, cornerRadius);
            uiCtx.stroke();

            // Profile picture placeholder - proportional to box height
            const picSize = Math.floor(boxHeight * 0.7);
            const picMargin = Math.floor(boxHeight * 0.15);
            const picX = boxX + picMargin;
            const picY = boxY + picMargin;

            uiCtx.fillStyle = 'rgba(80, 100, 120, 0.8)';
            uiCtx.beginPath();
            uiCtx.roundRect(picX, picY, picSize, picSize, Math.floor(picSize * 0.12));
            uiCtx.fill();

            uiCtx.strokeStyle = 'rgba(120, 150, 180, 0.8)';
            uiCtx.lineWidth = 2;
            uiCtx.beginPath();
            uiCtx.roundRect(picX, picY, picSize, picSize, Math.floor(picSize * 0.12));
            uiCtx.stroke();

            // "BOSS" title - font size proportional to box
            const titleFontSize = Math.max(10, Math.floor(boxHeight * 0.2));
            const textX = picX + picSize + picMargin;
            uiCtx.font = `bold ${titleFontSize}px Arial`;
            uiCtx.textAlign = 'left';
            uiCtx.textBaseline = 'top';
            uiCtx.fillStyle = '#FFD700';
            uiCtx.fillText('BOSS', textX, picY + 2);

            // Dialog text (character by character)
            if (dialogLines.length > 0 && currentDialogLine < dialogLines.length) {
                const fullLine = dialogLines[currentDialogLine];
                const displayText = fullLine.substring(0, currentDialogChar);

                const dialogFontSize = Math.max(12, Math.floor(boxHeight * 0.22));
                uiCtx.font = `${dialogFontSize}px Arial`;
                uiCtx.fillStyle = '#FFF';
                uiCtx.textBaseline = 'top';
                uiCtx.fillText(displayText, textX, picY + titleFontSize + 6);
            }
        }

        function renderFlingIndicator() {
            const pullX = flingCurrent.x - flingStart.x;
            const pullY = flingCurrent.y - flingStart.y;
            const rawPull = Math.sqrt(pullX * pullX + pullY * pullY);

            // Only show indicator when pulling down (forward throw)
            if (pullY <= 0) {
                return;
            }

            // Linear power scaling for precise control at low power
            // Max raw pull proportional to screen height
            const maxRawPull = CONFIG.HEIGHT * 0.4;
            const power = Math.min(100, Math.max(1, Math.round(100 * rawPull / maxRawPull)));

            // Scale visual elements proportionally
            const lineWidth = Math.max(1, Math.floor(CONFIG.WIDTH * 0.005));
            const arrowSize = Math.floor(CONFIG.WIDTH * 0.03);
            const fontSize = Math.max(12, Math.floor(CONFIG.WIDTH * 0.04));

            // Pull line (where finger dragged)
            uiCtx.strokeStyle = 'rgba(255, 200, 100, 0.6)';
            uiCtx.lineWidth = lineWidth;
            uiCtx.setLineDash([5, 5]);
            uiCtx.beginPath();
            uiCtx.moveTo(flingStart.x, flingStart.y);
            uiCtx.lineTo(flingCurrent.x, flingCurrent.y);
            uiCtx.stroke();
            uiCtx.setLineDash([]);

            // Throw direction indicator - always points UP (forward into screen)
            const throwLength = Math.max(arrowSize * 0.5, power * arrowSize * 0.05);
            const throwEndX = flingStart.x;
            const throwEndY = flingStart.y - throwLength;

            uiCtx.strokeStyle = `rgba(255, 80, 80, ${0.5 + power / 200})`;
            uiCtx.lineWidth = lineWidth * 2 + power / 25;
            uiCtx.lineCap = 'round';

            uiCtx.beginPath();
            uiCtx.moveTo(flingStart.x, flingStart.y);
            uiCtx.lineTo(throwEndX, throwEndY);
            uiCtx.stroke();

            // Arrowhead pointing up
            uiCtx.beginPath();
            uiCtx.moveTo(throwEndX, throwEndY);
            uiCtx.lineTo(throwEndX - arrowSize, throwEndY + arrowSize * 1.25);
            uiCtx.moveTo(throwEndX, throwEndY);
            uiCtx.lineTo(throwEndX + arrowSize, throwEndY + arrowSize * 1.25);
            uiCtx.stroke();

            // Power indicator
            uiCtx.font = `bold ${fontSize}px Arial`;
            uiCtx.textAlign = 'center';
            uiCtx.textBaseline = 'bottom';
            uiCtx.fillStyle = 'rgba(0,0,0,0.5)';
            uiCtx.fillText(`${Math.round(power)}%`, flingStart.x + 1, throwEndY - fontSize * 0.5);
            uiCtx.fillStyle = '#FFF';
            uiCtx.fillText(`${Math.round(power)}%`, flingStart.x, throwEndY - fontSize * 0.5 - 1);
        }

        function renderDictionaryPopup() {
            // Calculate button gap to know where dictionary starts
            const btnGap = Math.floor(CONFIG.HEIGHT * 0.03);
            const baseBtnHeight = Math.floor(CONFIG.WIDTH * 0.4 * 0.3125);

            // Dictionary starts below word letters and THROW IT button
            const dictStartY = CONFIG.WORD_Y + CONFIG.WORD_LETTER_SIZE + btnGap + baseBtnHeight + Math.floor(CONFIG.HEIGHT * 0.02);

            // Calculate available height for dictionary
            // Leave space for bottom UI (tidiness bar)
            const bottomMargin = Math.floor(CONFIG.HEIGHT * 0.12); // Reserve 12% for bottom UI
            const availableHeight = CONFIG.HEIGHT - dictStartY - bottomMargin;

            // Row height proportional to available space, aim for ~8 visible rows
            const targetVisibleRows = 8;
            const rowHeight = Math.floor(availableHeight / targetVisibleRows);
            const dictHeight = availableHeight;

            const margin = Math.floor(CONFIG.WIDTH * 0.0125); // Small margin
            const cornerRadius = Math.floor(CONFIG.WIDTH * 0.03);

            // Lighter background
            uiCtx.fillStyle = 'rgba(30, 40, 50, 0.95)';
            uiCtx.beginPath();
            uiCtx.roundRect(margin, dictStartY, CONFIG.WIDTH - margin * 2, dictHeight, cornerRadius);
            uiCtx.fill();

            // Border
            uiCtx.strokeStyle = 'rgba(100, 120, 140, 0.5)';
            uiCtx.lineWidth = 2;
            uiCtx.beginPath();
            uiCtx.roundRect(margin, dictStartY, CONFIG.WIDTH - margin * 2, dictHeight, cornerRadius);
            uiCtx.stroke();

            // Build word list: pre-selected words first, then rest
            const preSelectedSorted = preSelectedWords.slice().sort((a, b) => a.localeCompare(b));
            const otherWords = WORD_LIST.filter(w => !preSelectedWords.includes(w)).sort((a, b) => a.localeCompare(b));
            const allWords = [...preSelectedSorted, ...otherWords];

            const padding = Math.floor(CONFIG.WIDTH * 0.025);
            const startY = dictStartY + padding;
            const listHeight = dictHeight - padding * 2;
            const visibleRows = Math.floor(listHeight / rowHeight);
            const maxScroll = Math.max(0, allWords.length - visibleRows);

            // Scrollbar dimensions - proportional
            const scrollbarWidth = Math.floor(CONFIG.WIDTH * 0.06);
            const scrollbarX = CONFIG.WIDTH - scrollbarWidth - margin - padding;
            const trackY = startY + padding;
            const trackHeight = listHeight - padding * 2;

            // Clamp scroll
            dictScrollY = Math.max(0, Math.min(dictScrollY, maxScroll));

            const startIndex = Math.floor(dictScrollY);
            const endIndex = Math.min(startIndex + visibleRows + 1, allWords.length);

            // List area
            const listX = margin + padding;
            const listWidth = CONFIG.WIDTH - scrollbarWidth - margin * 2 - padding * 3;

            // Font size proportional to row height
            const wordFontSize = Math.max(12, Math.floor(rowHeight * 0.5));

            // Weight box size proportional to row height
            const boxSize = Math.max(8, Math.floor(rowHeight * 0.27));
            const boxGap = Math.max(2, Math.floor(boxSize * 0.3));

            uiCtx.save();
            uiCtx.beginPath();
            uiCtx.rect(0, startY, CONFIG.WIDTH, listHeight);
            uiCtx.clip();

            for (let i = startIndex; i < endIndex; i++) {
                const word = allWords[i];
                const y = startY + (i - dictScrollY) * rowHeight;
                const isPreSelected = preSelectedWords.includes(word);

                // Row background
                if (isPreSelected) {
                    uiCtx.fillStyle = 'rgba(60, 140, 60, 0.3)';
                    uiCtx.fillRect(listX, y, listWidth, rowHeight - 2);
                } else if (i % 2 === 0) {
                    uiCtx.fillStyle = 'rgba(255, 255, 255, 0.06)';
                    uiCtx.fillRect(listX, y, listWidth, rowHeight - 2);
                }

                // Word name - left aligned
                const hue = 40 + word.length * 20;
                uiCtx.font = `bold ${wordFontSize}px Arial`;
                uiCtx.fillStyle = isPreSelected ? '#8f8' : `hsl(${hue}, 70%, 70%)`;
                uiCtx.textAlign = 'left';
                uiCtx.textBaseline = 'middle';
                uiCtx.fillText(word, listX + padding, y + rowHeight / 2);

                // Weight boxes
                const weight = DICTIONARY[word].weight;
                const weightX = listX + listWidth - padding;

                for (let w = 0; w < 8; w++) {
                    const bx = weightX - (8 - w) * (boxSize + boxGap);
                    const by = y + rowHeight / 2 - boxSize / 2;

                    if (w < weight) {
                        const wHue = 120 - weight * 12;
                        uiCtx.fillStyle = `hsl(${wHue}, 65%, 55%)`;
                    } else {
                        uiCtx.fillStyle = 'rgba(255,255,255,0.1)';
                    }

                    uiCtx.beginPath();
                    uiCtx.roundRect(bx, by, boxSize, boxSize, Math.max(1, Math.floor(boxSize * 0.2)));
                    uiCtx.fill();
                }
            }

            uiCtx.restore();

            // Scrollbar track
            uiCtx.fillStyle = 'rgba(255, 255, 255, 0.12)';
            uiCtx.beginPath();
            uiCtx.roundRect(scrollbarX, trackY, scrollbarWidth, trackHeight, scrollbarWidth / 2);
            uiCtx.fill();

            // Scrollbar thumb
            if (allWords.length > visibleRows) {
                const thumbHeight = Math.max(Math.floor(CONFIG.HEIGHT * 0.08), (visibleRows / allWords.length) * trackHeight);
                const thumbY = trackY + (dictScrollY / maxScroll) * (trackHeight - thumbHeight);

                const gradient = uiCtx.createLinearGradient(scrollbarX, 0, scrollbarX + scrollbarWidth, 0);
                gradient.addColorStop(0, '#666');
                gradient.addColorStop(0.5, '#888');
                gradient.addColorStop(1, '#666');
                uiCtx.fillStyle = gradient;
                uiCtx.beginPath();
                uiCtx.roundRect(scrollbarX, thumbY, scrollbarWidth, thumbHeight, scrollbarWidth / 2);
                uiCtx.fill();

                uiCtx.fillStyle = 'rgba(255,255,255,0.2)';
                uiCtx.beginPath();
                uiCtx.roundRect(scrollbarX + 3, thumbY + 3, scrollbarWidth - 6, thumbHeight - 6, (scrollbarWidth - 6) / 2);
                uiCtx.fill();

                renderDictionaryPopup.scrollbar = {
                    x: scrollbarX,
                    y: trackY,
                    width: scrollbarWidth,
                    height: trackHeight,
                    thumbY: thumbY,
                    thumbHeight: thumbHeight,
                    maxScroll: maxScroll
                };
            }
        }

        function renderVictoryScreen() {
            // Skip rendering if in Remix (Remix handles its own game over UI)
            if (isInRemix()) return;

            uiCtx.fillStyle = 'rgba(0, 0, 0, 0.85)';
            uiCtx.fillRect(0, 0, CONFIG.WIDTH, CONFIG.HEIGHT);

            // Font sizes proportional to screen
            const titleFontSize = Math.floor(CONFIG.WIDTH * 0.08);
            const scoreFontSize = Math.floor(CONFIG.WIDTH * 0.07);
            const labelFontSize = Math.floor(CONFIG.WIDTH * 0.035);
            const infoFontSize = Math.floor(CONFIG.WIDTH * 0.045);

            uiCtx.fillStyle = '#FFD700';
            uiCtx.font = `bold ${titleFontSize}px Arial`;
            uiCtx.textAlign = 'center';
            uiCtx.textBaseline = 'middle';
            uiCtx.fillText('GARBIDUP', CONFIG.WIDTH / 2, CONFIG.HEIGHT * 0.3);
            uiCtx.fillText('CLEARED!', CONFIG.WIDTH / 2, CONFIG.HEIGHT * 0.3 + titleFontSize * 1.2);

            uiCtx.fillStyle = '#FFF';
            uiCtx.font = `${scoreFontSize}px Arial`;
            uiCtx.fillText(score.toString(), CONFIG.WIDTH / 2, CONFIG.HEIGHT * 0.5);
            uiCtx.font = `${labelFontSize}px Arial`;
            uiCtx.fillStyle = '#AAA';
            uiCtx.fillText('FINAL SCORE', CONFIG.WIDTH / 2, CONFIG.HEIGHT * 0.5 + scoreFontSize);

            uiCtx.fillStyle = '#FFF';
            uiCtx.font = `${infoFontSize}px Arial`;
            uiCtx.fillText(`Objects Flung: ${pilesCleared}`, CONFIG.WIDTH / 2, CONFIG.HEIGHT * 0.65);

            uiCtx.fillStyle = '#4CAF50';
            uiCtx.fillText('Tap to play again', CONFIG.WIDTH / 2, CONFIG.HEIGHT * 0.75);
        }

        // ============================================
        // INPUT HANDLING
        // ============================================
        function initInput() {
            uiCanvas.addEventListener('mousedown', handlePointerStart);
            uiCanvas.addEventListener('mousemove', handlePointerMove);
            uiCanvas.addEventListener('mouseup', handlePointerEnd);

            uiCanvas.addEventListener('touchstart', (e) => {
                e.preventDefault();
                handlePointerStart(e.touches[0]);
            });
            uiCanvas.addEventListener('touchmove', (e) => {
                e.preventDefault();
                handlePointerMove(e.touches[0]);
            });
            uiCanvas.addEventListener('touchend', (e) => {
                e.preventDefault();
                handlePointerEnd(e.changedTouches[0]);
            });

            // Mouse wheel for dictionary scroll
            uiCanvas.addEventListener('wheel', (e) => {
                if (showDictionary) {
                    e.preventDefault();
                    dictScrollY += e.deltaY * 0.02;
                }
            }, { passive: false });
        }

        function getCanvasCoords(event) {
            const rect = uiCanvas.getBoundingClientRect();
            const scaleX = CONFIG.WIDTH / rect.width;
            const scaleY = CONFIG.HEIGHT / rect.height;
            return {
                x: (event.clientX - rect.left) * scaleX,
                y: (event.clientY - rect.top) * scaleY
            };
        }

        // Dictionary scroll state
        let dictDragStart = null;
        let dictDragScrollStart = 0;
        let dictScrollbarDrag = false;

        function handlePointerStart(event) {
            const pos = getCanvasCoords(event);

            // During dialog, tapping advances or skips
            if (dialogActive && (gameState === 'INTRO' || gameState === 'TRANSITIONING')) {
                // If line is still typing, complete it instantly
                if (currentDialogChar < dialogLines[currentDialogLine].length) {
                    currentDialogChar = dialogLines[currentDialogLine].length;
                    dialogPauseTimer = 0;
                } else {
                    // Move to next line
                    currentDialogLine++;
                    currentDialogChar = 0;
                    dialogPauseTimer = 0;

                    if (currentDialogLine >= dialogLines.length) {
                        dialogActive = false;
                        if (gameState === 'INTRO') {
                            startLetterReveal();
                        } else if (gameState === 'TRANSITIONING') {
                            finishSuccessTransition();
                        }
                    }
                }
                return;
            }

            // During letter reveal, can't interact
            if (gameState === 'LETTER_REVEAL') {
                return;
            }

            // Dictionary button - top right - proportional to screen
            const dictBtnWidth = Math.floor(CONFIG.WIDTH * 0.325);
            const dictBtnHeight = Math.floor(CONFIG.HEIGHT * 0.067);
            const dictBtnX = CONFIG.WIDTH - dictBtnWidth - Math.floor(CONFIG.WIDTH * 0.025);
            const dictBtnY = Math.floor(CONFIG.HEIGHT * 0.02);

            if (pos.x >= dictBtnX && pos.x <= dictBtnX + dictBtnWidth &&
                pos.y >= dictBtnY && pos.y <= dictBtnY + dictBtnHeight) {
                showDictionary = !showDictionary; // Toggle dictionary
                return;
            }

            // Check letter interactions (works even with dictionary open)
            if (gameState === 'WORD_BUILDING') {
                // Pool letters (anagram row)
                for (let i = 0; i < letters.length; i++) {
                    if (letters[i].selected) continue;
                    if (!letters[i].revealed) continue;
                    const letter = letters[i];
                    if (pos.x >= letter.currentX && pos.x <= letter.currentX + CONFIG.LETTER_SIZE &&
                        pos.y >= letter.currentY && pos.y <= letter.currentY + CONFIG.LETTER_SIZE) {
                        selectLetter(i);
                        return;
                    }
                }
            }

            // Submit button - check even with dictionary open (closes dictionary and submits)
            if (gameState === 'WORD_BUILDING') {
                const word = getSelectedWord();
                if (isValidWord(word)) {
                    // Use same proportional calculation as rendering
                    const btnWidth = Math.floor(CONFIG.WIDTH * 0.4);
                    const btnHeight = Math.floor(btnWidth * 0.3125);
                    const btnGap = Math.floor(CONFIG.HEIGHT * 0.03);
                    const btnX = (CONFIG.WIDTH - btnWidth) / 2;
                    const btnY = CONFIG.WORD_Y + CONFIG.WORD_LETTER_SIZE + btnGap;

                    if (pos.x >= btnX && pos.x <= btnX + btnWidth &&
                        pos.y >= btnY && pos.y <= btnY + btnHeight) {
                        submitWord(); // This closes dictionary automatically
                        return;
                    }
                }
            }

            if (showDictionary) {
                // Calculate dictionary start Y using same formula as rendering
                const btnGap = Math.floor(CONFIG.HEIGHT * 0.03);
                const baseBtnHeight = Math.floor(CONFIG.WIDTH * 0.4 * 0.3125);
                const dictStartY = CONFIG.WORD_Y + CONFIG.WORD_LETTER_SIZE + btnGap + baseBtnHeight + Math.floor(CONFIG.HEIGHT * 0.02);

                // Only interact with dictionary scrollbar if clicking within dictionary area
                if (pos.y >= dictStartY) {
                    const sb = renderDictionaryPopup.scrollbar;
                    if (sb && pos.x >= sb.x && pos.x <= sb.x + sb.width) {
                        if (pos.y >= sb.y && pos.y <= sb.y + sb.height) {
                            dictScrollbarDrag = true;
                            if (pos.y < sb.thumbY || pos.y > sb.thumbY + sb.thumbHeight) {
                                const clickRatio = (pos.y - sb.y) / sb.height;
                                dictScrollY = clickRatio * sb.maxScroll;
                            }
                            dictDragStart = pos.y;
                            dictDragScrollStart = dictScrollY;
                            return;
                        }
                    }

                    // Start drag scroll on list area
                    dictDragStart = pos.y;
                    dictDragScrollStart = dictScrollY;
                    dictScrollbarDrag = false;
                    return;
                }
                // Allow clicks above dictionary area to fall through to word letter handling
            }

            if (gameState === 'VICTORY') {
                resetGame();
                return;
            }

            if (gameState === 'WORD_BUILDING') {
                // Word area letters - use WORD_LETTER_SIZE for hit detection
                for (let orderIndex = selectedOrder.length - 1; orderIndex >= 0; orderIndex--) {
                    const letterIndex = selectedOrder[orderIndex];
                    const letter = letters[letterIndex];
                    const wordSize = CONFIG.WORD_LETTER_SIZE;
                    if (pos.x >= letter.currentX && pos.x <= letter.currentX + wordSize &&
                        pos.y >= letter.currentY && pos.y <= letter.currentY + wordSize) {
                        deselectLetter(letterIndex);
                        return;
                    }
                }
            }

            if (gameState === 'FLING') {
                flingStart = pos;
                flingCurrent = pos;
                isFlingReady = true;
            }
        }

        function handlePointerMove(event) {
            const pos = getCanvasCoords(event);

            if (showDictionary && dictDragStart !== null) {
                if (dictScrollbarDrag) {
                    // Dragging scrollbar thumb directly
                    const sb = renderDictionaryPopup.scrollbar;
                    if (sb) {
                        const deltaY = pos.y - dictDragStart;
                        const scrollRatio = deltaY / (sb.height - sb.thumbHeight);
                        dictScrollY = dictDragScrollStart + scrollRatio * sb.maxScroll;
                    }
                } else {
                    // Drag scroll in list area (inverted)
                    const deltaY = dictDragStart - pos.y;
                    const rowHeight = 52; // Match dictionary row height
                    dictScrollY = dictDragScrollStart + deltaY / rowHeight;
                }
            }

            if (gameState === 'FLING' && isFlingReady) {
                flingCurrent = pos;
            }
        }

        function handlePointerEnd(event) {
            const pos = getCanvasCoords(event);

            if (showDictionary) {
                const dictStartY = CONFIG.WORD_Y + CONFIG.WORD_LETTER_SIZE + 80;

                // Tap within dictionary area (not scrollbar drag) closes it
                if (dictDragStart !== null && !dictScrollbarDrag && pos.y >= dictStartY) {
                    const deltaY = Math.abs(dictDragStart - pos.y);
                    if (deltaY < 10) {
                        showDictionary = false;
                    }
                }
                dictDragStart = null;
                dictScrollbarDrag = false;
                return;
            }

            if (gameState === 'FLING' && isFlingReady && flingStart) {
                performFling(pos);
                flingStart = null;
                flingCurrent = null;
                isFlingReady = false;
            }
        }

        function submitWord() {
            const word = getSelectedWord();
            if (!isValidWord(word)) return;

            // Close dictionary if open
            showDictionary = false;

            const activePiles = trashPiles.map((p, i) => ({ pile: p, index: i })).filter(p => p.pile.active);
            if (activePiles.length === 0) {
                gameState = 'VICTORY';
                signalGameOver(score);
                return;
            }

            // Use the pending pile that was already shown in preview, or fall back to random
            let chosenIndex = pendingPileIndex;
            if (chosenIndex === -1 || !trashPiles[chosenIndex]?.active) {
                const hash = word.split('').reduce((acc, c) => acc + c.charCodeAt(0), 0);
                chosenIndex = activePiles[hash % activePiles.length].index;
            }

            activePileIndex = chosenIndex;
            const chosenPile = trashPiles[chosenIndex];

            currentObject = {
                word: word,
                weight: DICTIONARY[word].weight,
                x: chosenPile.x,
                y: 2,
                z: chosenPile.z,
                vx: 0,
                vy: 0,
                vz: 0,
                rotation: 0,
                rotationSpeed: 0
            };

            createObjectMesh(word, currentObject.weight);
            objectMesh.position.set(currentObject.x, currentObject.y, currentObject.z);

            // Highlight pile
            if (chosenPile.mesh) {
                chosenPile.mesh.children.forEach(child => {
                    if (child.material) {
                        child.userData.originalColor = child.material.color.getHex();
                        child.material.emissive = new THREE.Color(0x444400);
                    }
                });
            }

            shotsTaken = 0;
            trailPoints = [];
            updateTrail(); // Clear the trail line

            // Snap camera behind object
            cameraMode = 'DUMPYARD';
            setCameraBehindObject();

            gameState = 'OBJECT_SPAWN';
            pendingPileIndex = -1; // Reset pending pile

            setTimeout(() => {
                if (gameState === 'OBJECT_SPAWN') {
                    gameState = 'FLING';
                }
            }, 1000);
        }

        function performFling(endPos) {
            if (!currentObject) return;

            const pullX = endPos.x - flingStart.x;
            const pullY = endPos.y - flingStart.y;

            // Only accept downward pulls (forward throws)
            if (pullY <= 0) return;

            const rawPull = Math.sqrt(pullX * pullX + pullY * pullY);

            // Linear power scaling (matches indicator) - proportional to screen
            const maxRawPull = CONFIG.HEIGHT * 0.4;
            const clampedPull = Math.min(rawPull, maxRawPull);
            const normalizedPower = clampedPull / maxRawPull; // 0 to 1

            // Linear weight: weight 8 travels 1/8 as far as weight 1
            const weightFactor = 1 / currentObject.weight;

            const directionMultiplier = (cameraMode === 'DUMPYARD') ? 1 : -1;

            // Velocities tuned so weight 8 at 100% power can reach lake from back of dumpyard
            // Back of dumpyard: z  5, lake starts at z = 80 (LAKE_Z - LAKE_WIDTH/2 = 100 - 20)
            // Need ~75 units of travel for weight 8 at 100% power
            currentObject.vz = normalizedPower * 6.5 * weightFactor * directionMultiplier;

            // Lateral velocity - normalized to screen width
            currentObject.vx = -pullX / CONFIG.WIDTH * 1.2 * weightFactor;

            // Vertical velocity for nice arc
            currentObject.vy = 0.06 + normalizedPower * 0.7 * weightFactor;

            // Spin
            currentObject.rotationSpeed = (Math.random() - 0.5) * 0.08 + pullX / CONFIG.WIDTH * 0.12;

            trailPoints = [];
            shotsTaken++;
            gameState = 'FLYING';
        }

        // ============================================
        // GAME LOGIC
        // ============================================
        let lastUpdateTime = 0;

        function update() {
            const now = performance.now();
            const deltaTime = lastUpdateTime ? now - lastUpdateTime : 16;
            lastUpdateTime = now;

            // Dialog animation
            if (dialogActive && dialogLines.length > 0) {
                if (currentDialogLine < dialogLines.length) {
                    const currentLine = dialogLines[currentDialogLine];

                    if (currentDialogChar < currentLine.length) {
                        // Reveal characters
                        dialogCharTimer += deltaTime;
                        if (dialogCharTimer >= DIALOG_CHAR_SPEED) {
                            dialogCharTimer = 0;
                            currentDialogChar++;
                        }
                    } else {
                        // Line complete, wait then advance
                        dialogPauseTimer += deltaTime;
                        if (dialogPauseTimer >= DIALOG_PAUSE_TIME) {
                            dialogPauseTimer = 0;
                            currentDialogChar = 0;
                            currentDialogLine++;

                            // Check if dialog is done
                            if (currentDialogLine >= dialogLines.length) {
                                dialogActive = false;
                                // Start letter reveal animation after intro dialog
                                if (gameState === 'INTRO') {
                                    startLetterReveal();
                                } else if (gameState === 'TRANSITIONING') {
                                    // After success dialog, transition to next round
                                    finishSuccessTransition();
                                }
                            }
                        }
                    }
                }
            }

            // Letter reveal animation (80ms between each letter)
            if (letterAnimationQueue.length > 0) {
                letterAnimationTimer += deltaTime;
                if (letterAnimationTimer >= 80) {
                    letterAnimationTimer = 0;
                    const letterIndex = letterAnimationQueue.shift();
                    letters[letterIndex].revealed = true;

                    // If all letters revealed, start game
                    if (letterAnimationQueue.length === 0) {
                        gameState = 'WORD_BUILDING';
                    }
                }
            }

            // Letter animations (position and size)
            for (let i = 0; i < letters.length; i++) {
                const letter = letters[i];
                if (!letter.revealed) continue;

                let targetX = letter.selected ? letter.wordX : letter.poolX;
                let targetY = letter.selected ? letter.wordY : letter.poolY;
                let targetSize = letter.selected ? CONFIG.WORD_LETTER_SIZE : CONFIG.LETTER_SIZE;

                letter.currentX += (targetX - letter.currentX) * CONFIG.ANIM_SPEED;
                letter.currentY += (targetY - letter.currentY) * CONFIG.ANIM_SPEED;
                letter.currentSize = letter.currentSize || 5;
                letter.currentSize += (targetSize - letter.currentSize) * CONFIG.ANIM_SPEED;
            }

            // Message timer
            if (messageTimer > 0) {
                messageTimer -= 16;
            }

            // Camera interpolation - faster during flight, smooth lookAt
            const cameraLerpSpeed = (gameState === 'FLYING') ? 0.12 : 0.06;
            camera.position.lerp(targetCameraPos, cameraLerpSpeed);

            // Smooth lookAt by interpolating a look target point
            if (!camera.userData.currentLookAt) {
                camera.userData.currentLookAt = targetCameraLook.clone();
            }
            camera.userData.currentLookAt.lerp(targetCameraLook, cameraLerpSpeed);
            camera.lookAt(camera.userData.currentLookAt);

            // Object physics
            if (gameState === 'FLYING' && currentObject) {
                // Gravity
                currentObject.vy -= CONFIG.GRAVITY;

                // Air resistance
                currentObject.vx *= CONFIG.AIR_RESISTANCE;
                currentObject.vz *= CONFIG.AIR_RESISTANCE;

                // Update position
                currentObject.x += currentObject.vx;
                currentObject.y += currentObject.vy;
                currentObject.z += currentObject.vz;
                currentObject.rotation += currentObject.rotationSpeed;

                // Clamp position to stay within playable bounds
                const lakeStart = CONFIG.LAKE_Z - CONFIG.LAKE_WIDTH / 2;
                const lakeEnd = CONFIG.LAKE_Z + CONFIG.LAKE_WIDTH / 2;
                const minZ = -5;
                const maxZ = lakeEnd + 30; // Allow some overshoot into grass but not infinite
                const maxX = CONFIG.CORRIDOR_WIDTH / 2 - 2;

                // If object would go past bounds, clamp it and kill that velocity component
                if (currentObject.z < minZ) {
                    currentObject.z = minZ;
                    currentObject.vz = 0;
                } else if (currentObject.z > maxZ) {
                    currentObject.z = maxZ;
                    currentObject.vz = 0;
                }

                if (Math.abs(currentObject.x) > maxX) {
                    currentObject.x = Math.sign(currentObject.x) * maxX;
                    currentObject.vx = 0;
                }

                // Update mesh
                if (objectMesh) {
                    objectMesh.position.set(currentObject.x, currentObject.y, currentObject.z);
                    objectMesh.rotation.z = currentObject.rotation;
                    objectMesh.rotation.x = currentObject.rotation * 0.5;
                }

                // Camera follows object - directly behind
                if (cameraMode === 'DUMPYARD') {
                    targetCameraPos.set(
                        currentObject.x,
                        Math.max(4, currentObject.y + 3),
                        currentObject.z - 18
                    );
                    targetCameraLook.set(currentObject.x, Math.max(0, currentObject.y - 1), currentObject.z + 15);
                } else {
                    // Viewing from grass side
                    targetCameraPos.set(
                        currentObject.x,
                        Math.max(4, currentObject.y + 3),
                        currentObject.z + 18
                    );
                    targetCameraLook.set(currentObject.x, Math.max(0, currentObject.y - 1), currentObject.z - 15);
                }

                // Check landing
                if (currentObject.y <= 0 && currentObject.vy < 0) {
                    currentObject.y = 0.5;
                    currentObject.vy = 0;
                    currentObject.vx = 0;
                    currentObject.vz = 0;
                    currentObject.rotationSpeed = 0;

                    if (objectMesh) {
                        objectMesh.position.y = 0.5;
                    }

                    const lakeStart = CONFIG.LAKE_Z - CONFIG.LAKE_WIDTH / 2;
                    const lakeEnd = CONFIG.LAKE_Z + CONFIG.LAKE_WIDTH / 2;

                    if (currentObject.z >= lakeStart && currentObject.z <= lakeEnd) {
                        handleSuccess();
                        return; // Exit update - currentObject is now null
                    } else if (currentObject.z < lakeStart) {
                        // Landed short - stay here, shoot toward lake
                        cameraMode = 'DUMPYARD';
                        trailPoints = [];
                        updateTrail();
                        setCameraBehindObject();
                        gameState = 'FLING';
                    } else if (currentObject.z > lakeEnd) {
                        // Overshot - stay here, shoot back toward lake
                        cameraMode = 'GRASS';
                        trailPoints = [];
                        updateTrail();
                        setCameraBehindObject();
                        gameState = 'FLING';
                    }
                }
            }
        }

        function handleSuccess() {
            const thrownWord = currentObject.word; // Store before clearing
            const wordPoints = thrownWord.length * CONFIG.POINTS_PER_LETTER;
            const shotPenalty = (shotsTaken - 1) * CONFIG.SHOT_PENALTY;
            const bonus = shotsTaken === 1 ? CONFIG.PERFECT_BONUS : 0;
            const earnedPoints = Math.max(0, wordPoints - shotPenalty + bonus);

            score += earnedPoints;
            pilesCleared++;

            // Remove pile
            if (activePileIndex >= 0 && trashPiles[activePileIndex]) {
                const pile = trashPiles[activePileIndex];
                pile.active = false;
                if (pile.mesh) {
                    scene.remove(pile.mesh);
                }
            }

            // Remove object
            if (objectMesh) {
                scene.remove(objectMesh);
                objectMesh = null;
            }

            trailPoints = [];
            updateTrail();

            const pilesLeft = trashPiles.filter(p => p.active).length;
            if (pilesLeft === 0) {
                gameState = 'TRANSITIONING';
                currentObject = null;
                activePileIndex = -1;
                setTimeout(() => {
                    gameState = 'VICTORY';
                    signalGameOver(score);
                }, 1500);
                return;
            }

            // Set state immediately to avoid race condition
            gameState = 'TRANSITIONING';
            currentObject = null;
            activePileIndex = -1;

            // Show boss dialog after successful shot
            startSuccessDialog(thrownWord);
        }

        function startSuccessDialog(itemName) {
            const successLines = [
                `Good riddance. Who needs ${itemName}.`,
                "Beauty. Keep going.",
                "Ahh, this place feels cleaner already.",
                "The best junk is junk out of my yard."
            ];

            dialogActive = true;
            dialogLines = [successLines[Math.floor(Math.random() * successLines.length)]];
            currentDialogLine = 0;
            currentDialogChar = 0;
            dialogCharTimer = 0;
            dialogPauseTimer = 0;
        }

        function finishSuccessTransition() {
            generateLetterPool();
            cameraMode = 'DUMPYARD';
            targetCameraPos.set(0, 5, -10);
            targetCameraLook.set(0, 0, 50);
            gameState = 'WORD_BUILDING';
        }

        function showMessage(msg) {
            message = msg;
            messageTimer = 1500;
        }

        function setCameraBehindObject() {
            // Sets the target camera position directly behind the object (smooth transition)
            if (!currentObject) return;

            if (cameraMode === 'DUMPYARD') {
                // Directly behind object, looking toward lake
                targetCameraPos.set(currentObject.x, 5, currentObject.z - 18);
                targetCameraLook.set(currentObject.x, 1, currentObject.z + 30);
            } else {
                // Directly behind object on grass side, looking toward dumpyard
                targetCameraPos.set(currentObject.x, 5, currentObject.z + 18);
                targetCameraLook.set(currentObject.x, 1, currentObject.z - 30);
            }
        }

        // ============================================
        // GAME LOOP
        // ============================================
        function gameLoop() {
            update();
            renderer.render(scene, camera);
            renderUI();
            requestAnimationFrame(gameLoop);
        }

        function startIntroDialog() {
            dialogActive = true;
            dialogLines = [
                `Hey, ${playerName}!`,
                "We have a big problem!",
                "This dumpyard is full, and there's more trash coming!",
                "Thankfully, we've got a perfectly fine lake over there...",
                "You know what to do."
            ];
            currentDialogLine = 0;
            currentDialogChar = 0;
            dialogCharTimer = 0;
            dialogPauseTimer = 0;
        }

        function startLetterReveal() {
            // Letters are already in queue from generateLetterPool
            letterAnimationTimer = 0;
            gameState = 'LETTER_REVEAL';
        }

        function resetGame() {
            score = 0;
            pilesCleared = 0;
            shotsTaken = 0;
            currentObject = null;
            activePileIndex = -1;
            pendingPileIndex = -1;
            showDictionary = false;
            cameraMode = 'DUMPYARD';

            if (objectMesh) {
                scene.remove(objectMesh);
                objectMesh = null;
            }

            trailPoints = [];
            updateTrail();

            targetCameraPos.set(0, 5, -10);
            targetCameraLook.set(0, 0, 50);
            camera.position.copy(targetCameraPos);
            camera.userData.currentLookAt = targetCameraLook.clone();
            camera.lookAt(targetCameraLook);

            createTrashPiles();
            generateLetterPool();

            // Start intro dialog
            gameState = 'INTRO';
            startIntroDialog();
        }

        function init() {
            initThree();
            initUI();
            initInput();
            initRemixSDK();
            handleResize(); // Initial sizing
            resetGame();
            gameLoop();
        }

        init();
    </script>
</body>

</html>