<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>GARBIDUP</title>
    <link rel="icon" type="image/png" href="assets/item_can.png">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            touch-action: none;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
        }

        html,
        body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            background: #1a1a2e;
        }

        #container {
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
        }

        #gameWrapper {
            position: relative;
        }

        #threeCanvas,
        #uiCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        #threeCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        #uiCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: auto;
        }
    </style>
</head>

<body>
    <div id="container">
        <div id="gameWrapper">
            <canvas id="threeCanvas"></canvas>
            <canvas id="uiCanvas"></canvas>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@farcade/game-sdk@latest/dist/index.min.js"></script>
    <script>
        // Polyfill for roundRect if not available
        if (!CanvasRenderingContext2D.prototype.roundRect) {
            CanvasRenderingContext2D.prototype.roundRect = function (x, y, w, h, r) {
                if (w < 2 * r) r = w / 2;
                if (h < 2 * r) r = h / 2;
                this.moveTo(x + r, y);
                this.arcTo(x + w, y, x + w, y + h, r);
                this.arcTo(x + w, y + h, x, y + h, r);
                this.arcTo(x, y + h, x, y, r);
                this.arcTo(x, y, x + w, y, r);
                this.closePath();
                return this;
            };
        }

        // ============================================
        // CONFIGURATION
        // ============================================
        const CONFIG = {
            // Canvas dimensions will be set dynamically
            WIDTH: 400,
            HEIGHT: 600,

            // World dimensions (Three.js units) - elongated corridor
            CORRIDOR_WIDTH: 40,      // Narrower width
            WORLD_LENGTH: 200,       // Longer
            LAKE_Z: 100,             // Lake center position
            LAKE_WIDTH: 40,          // Lake width for balanced challenge

            // Gameplay
            LETTER_COUNT: 12,
            PILE_COUNT: 16,
            GRAVITY: 0.004,        // Lower gravity for longer, more dramatic arcs
            AIR_RESISTANCE: 0.998, // Less air resistance

            // Scoring
            POINTS_PER_LETTER: 100,

            // UI
            LETTER_SIZE: 30,       // Base size, will be calculated dynamically
            WORD_LETTER_SIZE: 38,  // Bigger letters for built word
            LETTER_GAP: 3,
            LETTER_Y: 72,          // Will be calculated dynamically in handleResize
            WORD_Y: 120,           // Will be calculated dynamically
            ANIM_SPEED: 0.15,
        };

        // ============================================
        // ASSET LOADING
        // ============================================
        const BASE_URL = 'https://garbidup.loiyaa.com/';

        function getAssetPath(relativePath) {
            // Check if running locally (file:// or localhost)
            const isLocal = window.location.protocol === 'file:' ||
                window.location.hostname === 'localhost' ||
                window.location.hostname === '127.0.0.1';

            if (isLocal) {
                return relativePath;
            } else {
                return BASE_URL + relativePath;
            }
        }

        // ============================================
        // MUSIC SYSTEM
        // ============================================
        const TRACK_COUNT = 8;
        const MUSIC_VOLUME = 0.2; // 20% volume
        let currentAudio = null;
        let nextAudio = null;
        let playedTracks = [];
        let currentTrackIndex = -1;
        let musicStarted = false;
        let preloadTimeout = null;
        let isTabVisible = true;

        function getRandomUnplayedTrack() {
            // If all tracks played, reset the list
            if (playedTracks.length >= TRACK_COUNT) {
                playedTracks = [];
            }

            // Get available tracks
            const available = [];
            for (let i = 1; i <= TRACK_COUNT; i++) {
                if (!playedTracks.includes(i)) {
                    available.push(i);
                }
            }

            // Pick random from available
            const randomIndex = Math.floor(Math.random() * available.length);
            return available[randomIndex];
        }

        function getTrackPath(trackNum) {
            const paddedNum = trackNum.toString().padStart(2, '0');
            return getAssetPath(`assets/track_${paddedNum}.mp3`);
        }

        function preloadNextTrack() {
            const nextTrackNum = getRandomUnplayedTrack();
            nextAudio = new Audio();
            nextAudio.src = getTrackPath(nextTrackNum);
            nextAudio.load();
            nextAudio.volume = (isMuted || !isTabVisible) ? 0 : MUSIC_VOLUME;

            // Store which track this is
            nextAudio.trackNum = nextTrackNum;
        }

        function playNextTrack() {
            // Don't start new tracks when tab is hidden
            if (!isTabVisible) {
                // Queue to play when tab becomes visible
                return;
            }

            // If we have a preloaded track, use it
            if (nextAudio) {
                currentAudio = nextAudio;
                nextAudio = null;
            } else {
                // Load a new track
                const trackNum = getRandomUnplayedTrack();
                currentAudio = new Audio();
                currentAudio.src = getTrackPath(trackNum);
                currentAudio.trackNum = trackNum;
            }

            // Mark track as played
            playedTracks.push(currentAudio.trackNum);
            currentTrackIndex = currentAudio.trackNum;

            // Set volume based on mute state and tab visibility
            currentAudio.volume = (isMuted || !isTabVisible) ? 0 : MUSIC_VOLUME;

            // Play the track
            currentAudio.play().catch(e => {
                // Autoplay blocked - will try again on user interaction
                console.log('Music autoplay blocked, will retry on interaction');
            });

            // When track ends, play next
            currentAudio.onended = () => {
                playNextTrack();
            };

            // Preload next track 2 minutes after this one starts
            if (preloadTimeout) {
                clearTimeout(preloadTimeout);
            }
            preloadTimeout = setTimeout(() => {
                preloadNextTrack();
            }, 2 * 60 * 1000); // 2 minutes
        }

        function startMusic() {
            if (musicStarted) return;
            musicStarted = true;
            playNextTrack();
        }

        function setMusicMuted(muted) {
            if (currentAudio) {
                currentAudio.volume = (muted || !isTabVisible) ? 0 : MUSIC_VOLUME;
            }
            if (nextAudio) {
                nextAudio.volume = (muted || !isTabVisible) ? 0 : MUSIC_VOLUME;
            }
        }

        // Pause everything when tab is not visible
        document.addEventListener('visibilitychange', () => {
            isTabVisible = !document.hidden;
            if (!isTabVisible) {
                // Mute and pause music
                if (currentAudio) {
                    currentAudio.volume = 0;
                    currentAudio.pause();
                }
            } else {
                // Reset lastUpdateTime to avoid huge deltaTime on resume
                lastUpdateTime = 0;

                // Resume music
                if (currentAudio && musicStarted) {
                    if (!isMuted) currentAudio.volume = MUSIC_VOLUME;
                    currentAudio.play().catch(() => { });
                }
            }
        });

        // ============================================
        // SOUND EFFECTS
        // ============================================
        const typeBlips = [];
        let wordFoundSound = null;
        let letterFlowSound = null;
        let openDictionarySound = null;
        let waterSplashSound = null;
        let throwItemSound = null;
        let letterClickSound = null;
        let thumpItemSound = null;

        function initSoundEffects() {
            // Preload type blip sounds
            for (let i = 1; i <= 3; i++) {
                const audio = new Audio();
                audio.src = getAssetPath(`assets/type_blip${i}.mp3`);
                audio.load();
                typeBlips.push(audio);
            }

            // Preload word found sound
            wordFoundSound = new Audio();
            wordFoundSound.src = getAssetPath('assets/word_found.mp3');
            wordFoundSound.load();

            // Preload letter flow sound
            letterFlowSound = new Audio();
            letterFlowSound.src = getAssetPath('assets/letter_flow.mp3');
            letterFlowSound.load();

            // Preload dictionary open sound
            openDictionarySound = new Audio();
            openDictionarySound.src = getAssetPath('assets/open_dictionary.mp3');
            openDictionarySound.load();

            // Preload water splash sound
            waterSplashSound = new Audio();
            waterSplashSound.src = getAssetPath('assets/water_splash.mp3');
            waterSplashSound.load();

            // Preload throw item sound
            throwItemSound = new Audio();
            throwItemSound.src = getAssetPath('assets/throw_item.mp3');
            throwItemSound.load();

            // Preload letter click sound
            letterClickSound = new Audio();
            letterClickSound.src = getAssetPath('assets/letter_click.mp3');
            letterClickSound.load();

            // Preload thump item sound
            thumpItemSound = new Audio();
            thumpItemSound.src = getAssetPath('assets/thump_item.mp3');
            thumpItemSound.load();
        }

        function playTypeBlip() {
            if (isMuted || !isTabVisible) return;
            const blip = typeBlips[Math.floor(Math.random() * typeBlips.length)];
            if (blip) {
                // Clone the audio to allow overlapping plays
                const sound = blip.cloneNode();
                sound.volume = 0.5;
                sound.play().catch(() => { });
            }
        }

        function playWordFound() {
            if (isMuted || !isTabVisible || !wordFoundSound) return;
            const sound = wordFoundSound.cloneNode();
            sound.volume = 0.7;
            sound.play().catch(() => { });
        }

        function playLetterFlow() {
            if (isMuted || !isTabVisible || !letterFlowSound) return;
            const sound = letterFlowSound.cloneNode();
            sound.volume = 0.6;
            sound.play().catch(() => { });
        }

        function playOpenDictionary() {
            if (isMuted || !isTabVisible || !openDictionarySound) return;
            const sound = openDictionarySound.cloneNode();
            sound.volume = 0.6;
            sound.play().catch(() => { });
        }

        function playWaterSplash() {
            if (isMuted || !isTabVisible || !waterSplashSound) return;
            const sound = waterSplashSound.cloneNode();
            sound.volume = 0.8;
            sound.play().catch(() => { });
        }

        function playThrowItem() {
            if (isMuted || !isTabVisible || !throwItemSound) return;
            const sound = throwItemSound.cloneNode();
            sound.volume = 0.7;
            sound.play().catch(() => { });
        }

        function playLetterClick() {
            if (isMuted || !isTabVisible || !letterClickSound) return;
            const sound = letterClickSound.cloneNode();
            sound.volume = 0.5;
            sound.play().catch(() => { });
        }

        function playThumpItem() {
            if (isMuted || !isTabVisible || !thumpItemSound) return;
            const sound = thumpItemSound.cloneNode();
            sound.volume = 0.7;
            sound.play().catch(() => { });
        }

        // ============================================
        // OBJECT DICTIONARY
        // ============================================
        const DICTIONARY = {
            // 3-letter
            'CAN': { weight: 1 }, 'BAG': { weight: 2 }, 'JAR': { weight: 1 },
            'BOX': { weight: 3 }, 'MUG': { weight: 1 }, 'PAN': { weight: 2 },
            'CUP': { weight: 1 }, 'LID': { weight: 2 }, 'TOY': { weight: 2 },
            'RAG': { weight: 1 }, 'WIG': { weight: 2 }, 'HAT': { weight: 1 },
            'EGG': { weight: 1 }, 'URN': { weight: 4 }, 'GUN': { weight: 4 },
            'BUS': { weight: 8 }, 'CAR': { weight: 8 },

            // 4-letter
            'TIRE': { weight: 3 }, 'LAMP': { weight: 2 }, 'BOOK': { weight: 2 },
            'DRUM': { weight: 4 }, 'PIPE': { weight: 2 }, 'ROPE': { weight: 2 },
            'VASE': { weight: 4 }, 'TRAY': { weight: 2 }, 'BOWL': { weight: 2 },
            'CAGE': { weight: 4 }, 'SOCK': { weight: 1 }, 'BOOT': { weight: 2 },
            'FORK': { weight: 1 }, 'CLOG': { weight: 2 }, 'GONG': { weight: 3 },
            'BUST': { weight: 5 }, 'WAND': { weight: 1 }, 'TUBA': { weight: 6 },
            'POLE': { weight: 5 }, 'SIGN': { weight: 4 }, 'OVEN': { weight: 7 },
            'SHOE': { weight: 2 }, 'COAT': { weight: 1 }, 'GATE': { weight: 6 },
            'DOOR': { weight: 5 }, 'DOLL': { weight: 1 },

            // 5-letter (weights 1-8)
            'CHAIR': { weight: 4 }, 'CRATE': { weight: 4 }, 'STOOL': { weight: 4 },
            'BRICK': { weight: 5 }, 'PLANT': { weight: 3 }, 'BOARD': { weight: 3 },
            'FRAME': { weight: 3 }, 'CLOCK': { weight: 3 }, 'RADIO': { weight: 3 },
            'TRUNK': { weight: 5 }, 'SPOON': { weight: 1 }, 'GLOBE': { weight: 3 },
            'GNOME': { weight: 3 }, 'TIARA': { weight: 2 },
            'SQUID': { weight: 2 }, 'BANJO': { weight: 3 }, 'CROCS': { weight: 2 },
            'ROBOT': { weight: 6 }, 'WATCH': { weight: 1 }, 'PANTS': { weight: 1 },
            'JEWEL': { weight: 1 }, 'PLANE': { weight: 8 }, 'DRESS': { weight: 1 },
            'DRYER': { weight: 7 }, 'BOAT': { weight: 4 }, 'PHONE': { weight: 1 },
            'TOWER': { weight: 8 }, 'CROWN': { weight: 2 }, 'IGLOO': { weight: 7 },
            'SWORD': { weight: 3 }, 'TABLE': { weight: 5 }, 'COUCH': { weight: 6 },
            'TRUCK': { weight: 8 }, 'ALIEN': { weight: 2 }, 'DONUT': { weight: 1 },
            'CANOE': { weight: 5 }, 'PLATE': { weight: 3 },

            // 6-letter (weights 1-8)
            'BUCKET': { weight: 3 }, 'BARREL': { weight: 6 }, 'BOTTLE': { weight: 2 },
            'MIRROR': { weight: 4 }, 'CARPET': { weight: 5 }, 'FRIDGE': { weight: 8 },
            'DRAWER': { weight: 5 }, 'LADDER': { weight: 6 }, 'HEATER': { weight: 6 },
            'BASKET': { weight: 3 }, 'FEDORA': { weight: 2 }, 'TURBAN': { weight: 2 },
            'CACTUS': { weight: 3 }, 'WALLET': { weight: 1 },
            'SPONGE': { weight: 1 }, 'CANNON': { weight: 6 },
            'ANCHOR': { weight: 8 }, 'PILLAR': { weight: 8 }, 'CAMERA': { weight: 2 },
            'LAPTOP': { weight: 2 }, 'WINDOW': { weight: 4 }, 'BANNER': { weight: 1 },
            'SHIELD': { weight: 4 }, 'MONKEY': { weight: 3 },

            // 7-letter (weights 1-8)
            'BATHTUB': { weight: 8 }, 'BICYCLE': { weight: 7 }, 'MONITOR': { weight: 5 },
            'FREEZER': { weight: 8 }, 'TOASTER': { weight: 3 }, 'BLENDER': { weight: 4 },
            'PRINTER': { weight: 6 }, 'CURTAIN': { weight: 3 }, 'UKULELE': { weight: 2 },
            'SPATULA': { weight: 2 }, 'HAMMOCK': { weight: 4 },
            'TRICORN': { weight: 2 }, 'COCONUT': { weight: 3 },
            'BAGPIPE': { weight: 4 }, 'COWBELL': { weight: 3 },
            'CHIMNEY': { weight: 8 }, 'BALCONY': { weight: 8 }, 'PENGUIN': { weight: 3 },
            'GLASSES': { weight: 1 },

            // 8-letter bonus (weights 2-7)
            'TROMBONE': { weight: 5 }, 'SOMBRERO': { weight: 2 }, 'UNICYCLE': { weight: 6 },
            'DOORKNOB': { weight: 3 }, 'FLAMINGO': { weight: 3 }, 'ARMCHAIR': { weight: 7 },
            'FISHBOWL': { weight: 4 }, 'TRASHCAN': { weight: 4 }, 'BACKPACK': { weight: 4 },
            'PAINTING': { weight: 3 }, 'COMPUTER': { weight: 4 },
        };

        const WORD_LIST = Object.keys(DICTIONARY);

        // ============================================
        // GAME STATE
        // ============================================
        let gameState = 'INTRO'; // Start with intro dialog
        let showDictionary = false;
        let showQuitConfirm = false;
        let dictScrollY = 0; // Scroll position for dictionary
        let animTime = 0; // Animation timer

        // Letters
        let letters = [];
        let selectedOrder = [];
        let letterAnimationQueue = []; // For intro animation
        let letterAnimationTimer = 0;

        // Pre-selected words for this round
        let preSelectedWords = [];

        // 3D objects
        let trashPiles = [];
        let currentObject = null;
        let objectMesh = null;
        let activePileIndex = -1;
        let pendingPileIndex = -1; // Preview of which pile will be used when word is submitted

        // Camera state
        let cameraMode = 'DUMPYARD'; // 'DUMPYARD' or 'GRASS'
        let targetCameraPos = new THREE.Vector3(0, 5, -10);
        let targetCameraLook = new THREE.Vector3(0, 0, 30);

        // Scoring
        let score = 0;
        let shotsTaken = 0;
        let pilesCleared = 0;

        // Messages
        let message = '';
        let messageTimer = 0;

        // Dialog system
        let dialogActive = false;
        let dialogLines = [];
        let currentDialogLine = 0;
        let currentDialogChar = 0;
        let dialogCharTimer = 0;
        let dialogPauseTimer = 0;
        const DIALOG_CHAR_SPEED = 30; // ms per character
        const DIALOG_PAUSE_TIME = 1000; // ms pause after line complete

        // Audio state (for future sound implementation)
        let isMuted = false;

        // Track word validity for sound effect
        let lastWordValid = false;

        // Track if we've shown the shoot hint
        let hasShownShootHint = false;

        // Player name (from Remix SDK or default)
        let playerName = 'Newbie';

        // ============================================
        // REMIX SDK INTEGRATION
        // ============================================
        function isInRemix() {
            return window.FarcadeSDK && window.self !== window.top;
        }

        async function initRemixSDK() {
            if (!window.FarcadeSDK) return;

            try {
                // Signal ready and get game info (including player data)
                const gameInfo = await window.FarcadeSDK.singlePlayer.actions.ready();

                // Extract player name if available
                if (gameInfo && gameInfo.players && gameInfo.players.length > 0) {
                    const player = gameInfo.players[0];
                    if (player.name) {
                        playerName = player.name;
                    }
                }
            } catch (e) {
                // If ready() fails, just continue with default name
            }

            // Handle play again requests from Remix
            window.FarcadeSDK.on('play_again', () => {
                resetGame();
            });

            // Handle mute/unmute requests from Remix
            window.FarcadeSDK.on('toggle_mute', (data) => {
                isMuted = data.isMuted;
                setMusicMuted(isMuted);
            });
        }

        function signalGameOver(finalScore) {
            if (!window.FarcadeSDK) return;
            window.FarcadeSDK.singlePlayer.actions.gameOver({ score: finalScore });
        }

        // Fling
        let flingStart = null;
        let flingCurrent = null;
        let isFlingReady = false;

        // Three.js
        let scene, camera, renderer;
        let uiCanvas, uiCtx;

        // Trail
        let trailPoints = [];
        let trailLine = null;

        // ============================================
        // THREE.JS SETUP
        // ============================================
        function initThree() {
            const threeCanvas = document.getElementById('threeCanvas');

            // Renderer - will be resized by handleResize
            renderer = new THREE.WebGLRenderer({ canvas: threeCanvas, antialias: true });
            renderer.setSize(CONFIG.WIDTH, CONFIG.HEIGHT);
            renderer.setClearColor(0x87CEEB);

            // Scene
            scene = new THREE.Scene();
            scene.fog = new THREE.Fog(0x87CEEB, 80, 200);

            // Camera - wider FOV to see more of the corridor
            camera = new THREE.PerspectiveCamera(70, CONFIG.WIDTH / CONFIG.HEIGHT, 0.1, 300);
            camera.position.set(0, 5, -10);
            camera.lookAt(0, 0, 50);

            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(10, 20, -10);
            scene.add(directionalLight);

            // Environment is built after textures load

            // Handle resize
            handleResize();
            window.addEventListener('resize', handleResize);
        }

        function handleResize() {
            const container = document.getElementById('container');
            const wrapper = document.getElementById('gameWrapper');

            const containerW = container.clientWidth;
            const containerH = container.clientHeight;
            const targetRatio = 2 / 3;

            let width, height;

            if (containerW / containerH > targetRatio) {
                // Container is wider than 2:3, fit to height
                height = containerH;
                width = height * targetRatio;
            } else {
                // Container is taller than 2:3, fit to width
                width = containerW;
                height = width / targetRatio;
            }

            wrapper.style.width = width + 'px';
            wrapper.style.height = height + 'px';

            // Update internal resolution
            CONFIG.WIDTH = Math.floor(width);
            CONFIG.HEIGHT = Math.floor(height);

            // Update Three.js renderer
            if (renderer) {
                renderer.setSize(CONFIG.WIDTH, CONFIG.HEIGHT);
                camera.aspect = CONFIG.WIDTH / CONFIG.HEIGHT;
                camera.updateProjectionMatrix();
            }

            // Update UI canvas
            if (uiCanvas) {
                uiCanvas.width = CONFIG.WIDTH;
                uiCanvas.height = CONFIG.HEIGHT;
            }

            // Always calculate LETTER_Y based on where top UI ends
            // Top UI (dictionary button) ends at HEIGHT * 0.02 + HEIGHT * 0.067 = HEIGHT * 0.087
            // Add a consistent gap below it
            const topUIEnd = Math.floor(CONFIG.HEIGHT * 0.087);
            const gapBelowUI = Math.max(12, Math.floor(CONFIG.HEIGHT * 0.02));
            CONFIG.LETTER_Y = topUIEnd + gapBelowUI;

            // Recalculate letter positions
            if (letters.length > 0) {
                // Calculate letter size to nearly fill screen width (with small margins)
                const margin = 16; // 8px on each side
                const availableWidth = CONFIG.WIDTH - margin;
                const letterSize = Math.floor((availableWidth - (CONFIG.LETTER_COUNT - 1) * CONFIG.LETTER_GAP) / CONFIG.LETTER_COUNT);
                CONFIG.LETTER_SIZE = letterSize;
                CONFIG.WORD_LETTER_SIZE = Math.floor(letterSize * 1.25); // Word letters 25% bigger
                CONFIG.WORD_Y = CONFIG.LETTER_Y + CONFIG.LETTER_SIZE + Math.floor(CONFIG.HEIGHT * 0.03);

                const totalWidth = CONFIG.LETTER_COUNT * CONFIG.LETTER_SIZE + (CONFIG.LETTER_COUNT - 1) * CONFIG.LETTER_GAP;
                const startX = (CONFIG.WIDTH - totalWidth) / 2;

                letters.forEach((letter, i) => {
                    letter.poolX = startX + i * (CONFIG.LETTER_SIZE + CONFIG.LETTER_GAP);
                    letter.poolY = CONFIG.LETTER_Y; // Update pool Y position
                    letter.wordY = CONFIG.WORD_Y; // Update word Y position
                    if (!letter.selected) {
                        letter.currentX = letter.poolX;
                        letter.currentY = letter.poolY;
                    }
                });

                updateWordPositions();
            }
        }

        function buildEnvironment() {
            const corridorWidth = CONFIG.CORRIDOR_WIDTH;
            const lakeZ = CONFIG.LAKE_Z;
            const lakeWidth = CONFIG.LAKE_WIDTH;
            const lakeStart = lakeZ - lakeWidth / 2;
            const lakeEnd = lakeZ + lakeWidth / 2;

            // Ground - Dumpyard (brown, from z=-10 to lake start)
            const dumpLength = lakeStart + 10;
            const dumpGeom = new THREE.BoxGeometry(corridorWidth, 1, dumpLength);

            let dumpMat;
            if (groundTexture) {
                // Calculate repeat based on ground size (512x512 texture = ~8 world units)
                const repeatX = corridorWidth / 8;
                const repeatZ = dumpLength / 8;
                groundTexture.repeat.set(repeatX, repeatZ);
                dumpMat = new THREE.MeshLambertMaterial({
                    map: groundTexture,
                    color: 0xffffff // Use white to show texture colors properly
                });
            } else {
                dumpMat = new THREE.MeshLambertMaterial({ color: 0x4a3728 });
            }

            const dumpGround = new THREE.Mesh(dumpGeom, dumpMat);
            dumpGround.position.set(0, -0.5, (lakeStart - 10) / 2);
            scene.add(dumpGround);

            // Lake (blue)
            const lakeGeom = new THREE.BoxGeometry(corridorWidth, 0.5, lakeWidth);
            const lakeMat = new THREE.MeshLambertMaterial({ color: 0x2e86ab });
            const lake = new THREE.Mesh(lakeGeom, lakeMat);
            lake.position.set(0, -0.3, lakeZ);
            scene.add(lake);

            // Lake surface shimmer
            const shimmerGeom = new THREE.PlaneGeometry(corridorWidth - 10, lakeWidth - 10);
            const shimmerMat = new THREE.MeshBasicMaterial({
                color: 0xffffff,
                transparent: true,
                opacity: 0.15
            });
            const shimmer = new THREE.Mesh(shimmerGeom, shimmerMat);
            shimmer.rotation.x = -Math.PI / 2;
            shimmer.position.set(0, 0.01, lakeZ);
            scene.add(shimmer);

            // Grass (green, from lake end onwards)
            const grassLength = 80;
            const grassGeom = new THREE.BoxGeometry(corridorWidth, 1, grassLength);

            let grassMat;
            if (grassTexture) {
                // Calculate repeat based on grass size (512x512 texture = ~8 world units)
                const repeatX = corridorWidth / 8;
                const repeatZ = grassLength / 8;
                grassTexture.repeat.set(repeatX, repeatZ);
                grassMat = new THREE.MeshLambertMaterial({
                    map: grassTexture,
                    color: 0xffffff
                });
            } else {
                grassMat = new THREE.MeshLambertMaterial({ color: 0x3d7a2d });
            }

            const grass = new THREE.Mesh(grassGeom, grassMat);
            grass.position.set(0, -0.5, lakeEnd + grassLength / 2);
            scene.add(grass);

            // Distant trees (simple boxes) - at the far end
            for (let i = 0; i < 8; i++) {
                // Trunk
                const trunkGeom = new THREE.BoxGeometry(1, 4, 1);
                const trunkMat = new THREE.MeshLambertMaterial({ color: 0x4a3020 });
                const trunk = new THREE.Mesh(trunkGeom, trunkMat);
                trunk.position.set(
                    (Math.random() - 0.5) * (corridorWidth - 5),
                    2,
                    lakeEnd + grassLength - 20 + Math.random() * 15
                );
                scene.add(trunk);

                // Foliage
                const foliageGeom = new THREE.BoxGeometry(3, 5, 3);
                const foliageMat = new THREE.MeshLambertMaterial({ color: 0x1a5a1a });
                const foliage = new THREE.Mesh(foliageGeom, foliageMat);
                foliage.position.set(trunk.position.x, 6, trunk.position.z);
                scene.add(foliage);
            }

            // Side walls/barriers (to make it feel like a corridor)
            const wallHeight = 3;
            const wallLength = CONFIG.WORLD_LENGTH;

            let wallMat;
            if (wallTexture) {
                // Wall texture is 256x140 (~1.83:1 ratio)
                // Tile along length, scale height appropriately
                const repeatX = wallLength / 8; // Repeat along length
                const repeatY = wallHeight / 4; // Repeat along height
                wallTexture.repeat.set(repeatX, repeatY);
                wallMat = new THREE.MeshLambertMaterial({
                    map: wallTexture,
                    color: 0xffffff
                });
            } else {
                wallMat = new THREE.MeshLambertMaterial({ color: 0x5a4a3a });
            }

            // Left wall
            const leftWallGeom = new THREE.BoxGeometry(2, wallHeight, wallLength);
            const leftWall = new THREE.Mesh(leftWallGeom, wallMat);
            leftWall.position.set(-corridorWidth / 2 - 1, wallHeight / 2, wallLength / 2 - 20);
            scene.add(leftWall);

            // Right wall
            const rightWall = new THREE.Mesh(leftWallGeom, wallMat);
            rightWall.position.set(corridorWidth / 2 + 1, wallHeight / 2, wallLength / 2 - 20);
            scene.add(rightWall);

            // Trail line (hidden for now - will be replaced with sprite effects later)
            // const trailMat = new THREE.LineBasicMaterial({ color: 0xffcc00, linewidth: 2 });
            // const trailGeom = new THREE.BufferGeometry();
            // trailLine = new THREE.Line(trailGeom, trailMat);
            // scene.add(trailLine);
            trailLine = null;
        }

        // Trash pile sprites
        const trashTextures = [];
        let trashTexturesLoaded = false;

        // Ground texture
        let groundTexture = null;
        // Wall texture
        let wallTexture = null;
        // Grass texture
        let grassTexture = null;
        // Fish textures
        let fishLeftTexture = null;
        let fishRightTexture = null;

        // Boss avatar
        let bossAvatarImage = null;
        let bossAvatarNumber = 0;

        // Active fish sprites for splash animation
        let activeFish = [];

        // Object fade when hitting lake
        let objectFading = false;
        let objectFadeStart = 0;

        // Floating score display
        let floatingScore = null; // { x, y, z, value, startTime }

        // Item sprite textures cache
        const itemTextures = new Map(); // word -> texture or null (failed) or 'loading'
        const textureLoader = new THREE.TextureLoader();

        function loadItemTexture(word) {
            if (itemTextures.has(word)) return; // Already loaded or loading

            itemTextures.set(word, 'loading');
            const path = getAssetPath(`assets/item_${word.toLowerCase()}.png`);

            textureLoader.load(
                path,
                (texture) => {
                    itemTextures.set(word, texture);
                    console.log(`Item texture loaded: ${word.toLowerCase()}`);
                },
                undefined,
                (error) => {
                    itemTextures.set(word, null); // Mark as failed
                }
            );
        }

        function loadTextures(onComplete) {
            const loader = new THREE.TextureLoader();
            let loadedCount = 0;
            let successCount = 0;
            const totalToLoad = 14; // 8 trash + 1 ground + 1 grass + 1 wall + 2 fish + 1 boss

            function checkComplete() {
                loadedCount++;
                if (loadedCount === totalToLoad) {
                    console.log(`Trash textures: ${successCount}/8 loaded successfully`);
                    trashTexturesLoaded = successCount > 0;
                    if (onComplete) onComplete();
                }
            }

            // Load boss avatar (pick 1 of 4 randomly for this game)
            bossAvatarNumber = 1 + Math.floor(Math.random() * 4);
            const bossPath = getAssetPath(`assets/boss_pfp${bossAvatarNumber}.jpg`);
            bossAvatarImage = new Image();
            bossAvatarImage.onload = () => {
                console.log(`Boss avatar ${bossAvatarNumber} loaded`);
                checkComplete();
            };
            bossAvatarImage.onerror = () => {
                console.log(`Failed to load boss_pfp${bossAvatarNumber}.jpg`);
                bossAvatarImage = null;
                checkComplete();
            };
            bossAvatarImage.src = bossPath;

            // Load ground texture
            const groundPath = getAssetPath('assets/ground_yard.png');
            loader.load(
                groundPath,
                (texture) => {
                    texture.wrapS = THREE.RepeatWrapping;
                    texture.wrapT = THREE.RepeatWrapping;
                    groundTexture = texture;
                    console.log('Ground texture loaded');
                    checkComplete();
                },
                undefined,
                (error) => {
                    console.log('Failed to load ground_yard.png, using fallback color');
                    checkComplete();
                }
            );

            // Load grass texture
            const grassPath = getAssetPath('assets/ground_grass.png');
            loader.load(
                grassPath,
                (texture) => {
                    texture.wrapS = THREE.RepeatWrapping;
                    texture.wrapT = THREE.RepeatWrapping;
                    grassTexture = texture;
                    console.log('Grass texture loaded');
                    checkComplete();
                },
                undefined,
                (error) => {
                    console.log('Failed to load ground_grass.png, using fallback color');
                    checkComplete();
                }
            );

            // Load wall texture
            const wallPath = getAssetPath('assets/wall.png');
            loader.load(
                wallPath,
                (texture) => {
                    texture.wrapS = THREE.RepeatWrapping;
                    texture.wrapT = THREE.RepeatWrapping;
                    wallTexture = texture;
                    console.log('Wall texture loaded');
                    checkComplete();
                },
                undefined,
                (error) => {
                    console.log('Failed to load wall.png, using fallback color');
                    checkComplete();
                }
            );

            // Load fish textures (left and right facing)
            const fishLeftPath = getAssetPath('assets/fish_left.png');
            loader.load(
                fishLeftPath,
                (texture) => {
                    fishLeftTexture = texture;
                    console.log('Fish left texture loaded');
                    checkComplete();
                },
                undefined,
                (error) => {
                    console.log('Failed to load fish_left.png');
                    checkComplete();
                }
            );

            const fishRightPath = getAssetPath('assets/fish_right.png');
            loader.load(
                fishRightPath,
                (texture) => {
                    fishRightTexture = texture;
                    console.log('Fish right texture loaded');
                    checkComplete();
                },
                undefined,
                (error) => {
                    console.log('Failed to load fish_right.png');
                    checkComplete();
                }
            );

            // Load trash textures
            for (let i = 1; i <= 8; i++) {
                const path = getAssetPath(`assets/trash_${i}.png`);
                loader.load(
                    path,
                    (texture) => {
                        trashTextures[i - 1] = texture;
                        successCount++;
                        checkComplete();
                    },
                    undefined,
                    (error) => {
                        console.log(`Failed to load trash_${i}.png, using fallback`);
                        checkComplete();
                    }
                );
            }
        }

        function createTrashPiles() {
            // Remove old piles
            trashPiles.forEach(pile => {
                if (pile.mesh) scene.remove(pile.mesh);
            });
            trashPiles = [];

            const lakeStart = CONFIG.LAKE_Z - CONFIG.LAKE_WIDTH / 2;
            const maxX = (CONFIG.CORRIDOR_WIDTH / 2) - 5;

            for (let i = 0; i < CONFIG.PILE_COUNT; i++) {
                // Spread piles along the dumpyard (from z=5 to just before lake)
                // Use a more varied distribution
                const row = Math.floor(i / 4); // 4 piles per row, 4 rows
                const col = i % 4;
                const rowZ = 8 + row * ((lakeStart - 20) / 4);
                const z = rowZ + (Math.random() - 0.5) * 8;
                const colX = (col - 1.5) * (maxX * 0.5);
                const x = colX + (Math.random() - 0.5) * 4;

                let pileMesh;
                const spriteIndex = i % 8; // Cycle through 8 sprites

                // Try to use sprite, fall back to 3D blocks
                if (trashTexturesLoaded && trashTextures[spriteIndex]) {
                    // Create billboard sprite
                    const material = new THREE.SpriteMaterial({
                        map: trashTextures[spriteIndex],
                        transparent: true,
                        opacity: 1.0
                    });
                    pileMesh = new THREE.Sprite(material);
                    // Sprites are ~256x120 (2:1 ratio width:height)
                    const scaleHeight = 2 + Math.random() * 1.5; // Random height variation
                    const scaleWidth = scaleHeight * 2.1; // Maintain ~2:1 aspect ratio
                    pileMesh.scale.set(scaleWidth, scaleHeight, 1);
                    pileMesh.position.set(x, scaleHeight / 2, z);
                    if (i === 0) console.log('Creating sprite-based trash piles');
                } else {
                    // Fallback: Create pile mesh (irregular stack of boxes)
                    if (i === 0) console.log('Creating fallback 3D trash piles (textures not loaded)');
                    const pileGroup = new THREE.Group();

                    const baseSize = 1.5 + Math.random();
                    for (let j = 0; j < 3 + Math.floor(Math.random() * 3); j++) {
                        const boxSize = baseSize * (1 - j * 0.2);
                        const boxGeom = new THREE.BoxGeometry(
                            boxSize + Math.random() * 0.5,
                            boxSize * 0.6,
                            boxSize + Math.random() * 0.5
                        );
                        const shade = 0x3a2a1a + Math.floor(Math.random() * 0x151515);
                        const boxMat = new THREE.MeshLambertMaterial({ color: shade });
                        const box = new THREE.Mesh(boxGeom, boxMat);
                        box.position.set(
                            (Math.random() - 0.5) * 0.5,
                            j * boxSize * 0.5 + boxSize * 0.3,
                            (Math.random() - 0.5) * 0.5
                        );
                        box.rotation.y = Math.random() * 0.5;
                        pileGroup.add(box);
                    }

                    pileGroup.position.set(x, 0, z);
                    pileMesh = pileGroup;
                }

                scene.add(pileMesh);

                trashPiles.push({
                    x: x,
                    z: z,
                    mesh: pileMesh,
                    active: true,
                    fading: false,
                    fadeStartTime: 0,
                    isSprite: trashTexturesLoaded && trashTextures[spriteIndex]
                });
            }
        }

        function startPileFade(pileIndex) {
            if (pileIndex >= 0 && trashPiles[pileIndex]) {
                const pile = trashPiles[pileIndex];
                pile.fading = true;
                pile.fadeStartTime = performance.now();
            }
        }

        function updatePileFades() {
            const now = performance.now();
            const fadeDuration = 4000; // 4 seconds

            for (let i = 0; i < trashPiles.length; i++) {
                const pile = trashPiles[i];
                if (!pile.mesh) continue;

                if (pile.fading) {
                    // Fading out after shot
                    const elapsed = now - pile.fadeStartTime;
                    const progress = Math.min(elapsed / fadeDuration, 1);
                    const opacity = 1 - progress;

                    if (pile.isSprite) {
                        pile.mesh.material.opacity = opacity;
                    } else {
                        pile.mesh.traverse((child) => {
                            if (child.material) {
                                child.material.transparent = true;
                                child.material.opacity = opacity;
                            }
                        });
                    }

                    // Remove when fully faded
                    if (progress >= 1) {
                        pile.fading = false;
                        scene.remove(pile.mesh);
                        pile.mesh = null;
                    }
                } else if (i === pendingPileIndex && gameState === 'WORD_BUILDING') {
                    // Pending pile pulsing animation (100% to 50% opacity)
                    const pulseSpeed = 3; // oscillations per second
                    const pulseOpacity = 0.75 + Math.sin(animTime * pulseSpeed) * 0.25; // 0.5 to 1.0

                    if (pile.isSprite) {
                        pile.mesh.material.opacity = pulseOpacity;
                    } else {
                        pile.mesh.traverse((child) => {
                            if (child.material) {
                                child.material.transparent = true;
                                child.material.opacity = pulseOpacity;
                            }
                        });
                    }
                } else if (!pile.fading && pile.active) {
                    // Reset opacity for non-pending, non-fading piles
                    if (pile.isSprite) {
                        pile.mesh.material.opacity = 1.0;
                    } else {
                        pile.mesh.traverse((child) => {
                            if (child.material) {
                                child.material.opacity = 1.0;
                            }
                        });
                    }
                }
            }
        }

        function spawnFishSplash(x, z) {
            if (!fishLeftTexture && !fishRightTexture) return;

            const fishCount = 4 + Math.floor(Math.random() * 3); // 4-6 fish

            for (let i = 0; i < fishCount; i++) {
                // Fish starts on one side and jumps to the other side
                const startsOnLeft = Math.random() < 0.5;

                // Choose texture based on direction AND camera side
                // From dumpyard: starting left = jumping right = use right-facing fish
                // From grass side: everything is flipped, so invert the logic
                let texture;
                if (cameraMode === 'GRASS') {
                    // Viewing from grass side - flip the texture choice
                    texture = startsOnLeft ? fishLeftTexture : fishRightTexture;
                } else {
                    // Viewing from dumpyard side
                    texture = startsOnLeft ? fishRightTexture : fishLeftTexture;
                }
                if (!texture) continue; // Skip if texture not loaded

                const material = new THREE.SpriteMaterial({
                    map: texture,
                    transparent: true,
                    alphaTest: 0.1 // Fix visible square around sprite
                });
                const fish = new THREE.Sprite(material);

                // Fish is 128x128, scale appropriately
                const scale = 1.2 + Math.random() * 0.4;
                fish.scale.set(scale, scale, 1);

                const lateralOffset = 0.5 + Math.random(); // 1-2 units away
                const depthOffset = (Math.random() - 0) * 4; // Slight z variation

                const startX = startsOnLeft ? (x - lateralOffset) : (x + lateralOffset);
                const endX = startsOnLeft ? (x + lateralOffset) : (x - lateralOffset);
                const startZ = z + depthOffset;
                const endZ = z + depthOffset + (Math.random() - 0.5) * 2;

                fish.position.set(startX, 0, startZ);

                scene.add(fish);

                // Store fish data for animation
                activeFish.push({
                    mesh: fish,
                    startX: startX,
                    startZ: startZ,
                    endX: endX,
                    endZ: endZ,
                    jumpHeight: 0.4 + Math.random() * 0.4, // Lower jump
                    duration: 400 + Math.random() * 400, // Faster
                    startTime: performance.now() + i * 100, // Stagger spawns
                    phase: 'waiting'
                });
            }
        }

        function updateFishAnimation() {
            const now = performance.now();

            for (let i = activeFish.length - 1; i >= 0; i--) {
                const fish = activeFish[i];

                if (fish.phase === 'waiting') {
                    if (now >= fish.startTime) {
                        fish.phase = 'jumping';
                        fish.jumpStartTime = now;
                    }
                    continue;
                }

                if (fish.phase === 'jumping') {
                    const elapsed = now - fish.jumpStartTime;
                    const progress = Math.min(elapsed / fish.duration, 1);

                    // Parabolic arc - highest at middle
                    const arcProgress = progress * 2 - 1; // -1 to 1
                    const height = fish.jumpHeight * (1 - arcProgress * arcProgress);

                    // Linear interpolation from start to end
                    const x = fish.startX + (fish.endX - fish.startX) * progress;
                    const z = fish.startZ + (fish.endZ - fish.startZ) * progress;

                    fish.mesh.position.set(x, height, z);

                    // Slight rotation based on arc (tilt up going up, down going down)
                    fish.mesh.material.rotation = -arcProgress * 0.4;

                    if (progress >= 1) {
                        fish.phase = 'done';
                        scene.remove(fish.mesh);
                        activeFish.splice(i, 1);
                    }
                }
            }
        }

        function updateObjectFade() {
            if (!objectFading || !objectMesh) return;

            const now = performance.now();
            const fadeDuration = 1500; // 1.5 seconds
            const elapsed = now - objectFadeStart;
            const progress = Math.min(elapsed / fadeDuration, 1);

            // Fade and sink
            objectMesh.traverse((child) => {
                if (child.material) {
                    child.material.transparent = true;
                    child.material.opacity = 1 - progress;
                }
            });
            objectMesh.position.y = 0.5 - progress * 2; // Sink into water

            if (progress >= 1) {
                scene.remove(objectMesh);
                objectMesh = null;
                objectFading = false;
            }
        }

        function createObjectMesh(word, weight) {
            // Remove old object
            if (objectMesh) {
                scene.remove(objectMesh);
            }

            // Try to use item sprite if available
            const texture = itemTextures.get(word);
            if (texture && texture !== 'loading' && texture !== null) {
                // Use sprite with proper aspect ratio
                const material = new THREE.SpriteMaterial({
                    map: texture,
                    transparent: true,
                    alphaTest: 0.1
                });
                objectMesh = new THREE.Sprite(material);

                // Scale based on weight (50% larger than before)
                // Base scale around 3 units, increasing with weight
                const baseScale = 2.25 + weight * 0.225;

                // Use texture's natural aspect ratio
                const imgWidth = texture.image.width;
                const imgHeight = texture.image.height;
                const aspectRatio = imgWidth / imgHeight;

                objectMesh.scale.set(baseScale * aspectRatio, baseScale, 1);
                scene.add(objectMesh);
                return objectMesh;
            }

            // Fallback: Create irregular triangular prism
            const size = 0.8 + weight * 0.1;
            const shape = new THREE.Shape();
            shape.moveTo(-size, -size * 0.5);
            shape.lineTo(size * 0.6, -size * 0.3);
            shape.lineTo(size * 0.3, size);
            shape.closePath();

            const extrudeSettings = { depth: size * 0.5, bevelEnabled: false };
            const geom = new THREE.ExtrudeGeometry(shape, extrudeSettings);

            // Color based on weight
            const hue = (50 - weight * 4) / 360;
            const color = new THREE.Color().setHSL(hue, 0.7, 0.5);
            const mat = new THREE.MeshLambertMaterial({ color: color });

            objectMesh = new THREE.Mesh(geom, mat);
            objectMesh.castShadow = true;

            // Add outline
            const edges = new THREE.EdgesGeometry(geom);
            const lineMat = new THREE.LineBasicMaterial({ color: 0x222222 });
            const outline = new THREE.LineSegments(edges, lineMat);
            objectMesh.add(outline);

            scene.add(objectMesh);

            return objectMesh;
        }

        function updateTrail() {
            // Trail disabled for now
        }

        // ============================================
        // UI CANVAS SETUP
        // ============================================
        function initUI() {
            uiCanvas = document.getElementById('uiCanvas');
            uiCtx = uiCanvas.getContext('2d');
            uiCanvas.width = CONFIG.WIDTH;
            uiCanvas.height = CONFIG.HEIGHT;
        }

        // ============================================
        // LETTER GENERATION
        // ============================================
        function canFormWord(word, availableLetters) {
            const letterCounts = {};
            availableLetters.forEach(c => letterCounts[c] = (letterCounts[c] || 0) + 1);

            for (const c of word) {
                if (!letterCounts[c] || letterCounts[c] <= 0) return false;
                letterCounts[c]--;
            }
            return true;
        }

        function getRequiredLetters(words) {
            // Get minimum letters needed to form all words
            const maxCounts = {};
            for (const word of words) {
                const counts = {};
                for (const c of word) {
                    counts[c] = (counts[c] || 0) + 1;
                }
                for (const [c, count] of Object.entries(counts)) {
                    maxCounts[c] = Math.max(maxCounts[c] || 0, count);
                }
            }

            let letters = [];
            for (const [c, count] of Object.entries(maxCounts)) {
                for (let i = 0; i < count; i++) {
                    letters.push(c);
                }
            }
            return letters;
        }

        // Store the game's 16 words (one per round, set once per game)
        let gameWords = [];

        function selectGameWords() {
            // Called ONCE at game start - picks 16 words, one for each round
            // These words stay constant for the entire game and appear as green in dictionary

            // Shuffle the word list
            const shuffled = [...WORD_LIST];
            for (let i = shuffled.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
            }

            // Pick 16 words with variety in length
            // Try to get a mix: some short, some medium, some long
            const byLength = {};
            for (const word of shuffled) {
                const len = word.length;
                if (!byLength[len]) byLength[len] = [];
                byLength[len].push(word);
            }

            gameWords = [];

            // Strategy: pick words in a varied pattern to ensure interesting gameplay
            // Aim for roughly: 4 short (3-4), 6 medium (5-6), 6 long (7-8)
            const targetCounts = { short: 4, medium: 6, long: 6 };
            const counts = { short: 0, medium: 0, long: 0 };

            for (const word of shuffled) {
                if (gameWords.length >= CONFIG.PILE_COUNT) break;

                const len = word.length;
                let category;
                if (len <= 4) category = 'short';
                else if (len <= 6) category = 'medium';
                else category = 'long';

                if (counts[category] < targetCounts[category]) {
                    gameWords.push(word);
                    counts[category]++;
                }
            }

            // If we didn't get 16, fill with any remaining words
            for (const word of shuffled) {
                if (gameWords.length >= CONFIG.PILE_COUNT) break;
                if (!gameWords.includes(word)) {
                    gameWords.push(word);
                }
            }

            // Shuffle the order so difficulty isn't predictable
            for (let i = gameWords.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [gameWords[i], gameWords[j]] = [gameWords[j], gameWords[i]];
            }

            // Store for dictionary display (sorted alphabetically)
            preSelectedWords = [...gameWords].sort((a, b) => a.localeCompare(b));
        }

        function generateLetterPool() {
            // Called each round - generates letters that guarantee the current round's word can be formed
            // Plus random filler letters weighted by English letter frequency

            // Get the word for this round (pilesCleared = current round index, 0-15)
            const currentRound = pilesCleared;
            const roundWord = gameWords[currentRound] || gameWords[0];

            // Start with letters required for this round's word
            let chars = roundWord.split('');

            // Letter frequency weights (roughly based on English)
            const letterWeights = {
                'E': 12, 'T': 9, 'A': 8, 'O': 8, 'I': 7, 'N': 7, 'S': 6, 'H': 6, 'R': 6,
                'D': 4, 'L': 4, 'C': 3, 'U': 3, 'M': 3, 'W': 2, 'F': 2, 'G': 2, 'Y': 2,
                'P': 2, 'B': 1, 'V': 1, 'K': 1, 'J': 1, 'X': 1, 'Q': 1, 'Z': 1
            };

            // Build weighted pool
            let weightedPool = [];
            for (const [letter, weight] of Object.entries(letterWeights)) {
                for (let i = 0; i < weight; i++) {
                    weightedPool.push(letter);
                }
            }

            // Track letter counts to avoid too many duplicates
            const letterCount = {};
            chars.forEach(c => letterCount[c] = (letterCount[c] || 0) + 1);

            // Fill remaining slots up to 12 letters
            while (chars.length < CONFIG.LETTER_COUNT) {
                // Ensure reasonable vowel/consonant balance
                const vowelCount = chars.filter(c => 'AEIOU'.includes(c)).length;
                const needVowel = vowelCount < 4 && Math.random() < 0.6;

                let letter;
                let attempts = 0;
                do {
                    letter = weightedPool[Math.floor(Math.random() * weightedPool.length)];
                    const isVowel = 'AEIOU'.includes(letter);
                    attempts++;
                    // Accept if: matches vowel need, or we've tried enough times
                    if ((needVowel === isVowel) || attempts > 20) break;
                } while (true);

                // Don't allow more than 2 of the same letter (unless word requires it)
                if ((letterCount[letter] || 0) < 2) {
                    chars.push(letter);
                    letterCount[letter] = (letterCount[letter] || 0) + 1;
                }
            }

            // Shuffle the letters
            for (let i = chars.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [chars[i], chars[j]] = [chars[j], chars[i]];
            }

            // Calculate letter sizes to fill screen
            const margin = 16;
            const availableWidth = CONFIG.WIDTH - margin;
            CONFIG.LETTER_SIZE = Math.floor((availableWidth - (CONFIG.LETTER_COUNT - 1) * CONFIG.LETTER_GAP) / CONFIG.LETTER_COUNT);
            CONFIG.WORD_LETTER_SIZE = Math.floor(CONFIG.LETTER_SIZE * 1.25);

            // Calculate LETTER_Y based on where top UI ends
            const topUIEnd = Math.floor(CONFIG.HEIGHT * 0.087);
            const gapBelowUI = Math.max(12, Math.floor(CONFIG.HEIGHT * 0.02));
            CONFIG.LETTER_Y = topUIEnd + gapBelowUI;
            CONFIG.WORD_Y = CONFIG.LETTER_Y + CONFIG.LETTER_SIZE + Math.floor(CONFIG.HEIGHT * 0.03);

            const totalWidth = CONFIG.LETTER_COUNT * CONFIG.LETTER_SIZE + (CONFIG.LETTER_COUNT - 1) * CONFIG.LETTER_GAP;
            const startX = (CONFIG.WIDTH - totalWidth) / 2;

            // Create letters - start at bottom center (tiny) for intro animation
            const centerX = CONFIG.WIDTH / 2;
            const bottomY = CONFIG.HEIGHT + 20;

            letters = chars.map((char, i) => ({
                char: char,
                poolX: startX + i * (CONFIG.LETTER_SIZE + CONFIG.LETTER_GAP),
                poolY: CONFIG.LETTER_Y,
                wordX: 0,
                wordY: CONFIG.WORD_Y,
                currentX: centerX,
                currentY: bottomY,
                currentSize: 5,
                targetSize: CONFIG.LETTER_SIZE,
                selected: false,
                animating: true,
                revealed: false
            }));

            selectedOrder = [];

            // Setup animation queue
            letterAnimationQueue = [];
            for (let i = 0; i < letters.length; i++) {
                letterAnimationQueue.push(i);
            }
            letterAnimationTimer = 0;
        }

        function getSelectedWord() {
            return selectedOrder.map(i => letters[i].char).join('');
        }

        function isValidWord(word) {
            return DICTIONARY.hasOwnProperty(word);
        }

        function updateWordPositions() {
            const count = selectedOrder.length;
            if (count === 0) return;

            const wordLetterSize = CONFIG.WORD_LETTER_SIZE;
            const totalWidth = count * wordLetterSize + (count - 1) * CONFIG.LETTER_GAP;
            const startX = (CONFIG.WIDTH - totalWidth) / 2;

            selectedOrder.forEach((letterIndex, orderIndex) => {
                letters[letterIndex].wordX = startX + orderIndex * (wordLetterSize + CONFIG.LETTER_GAP);
            });
        }

        function selectLetter(index) {
            if (letters[index].selected) return;
            letters[index].selected = true;
            letters[index].animating = true;
            selectedOrder.push(index);
            playLetterClick();
            updateWordPositions();
            updatePendingPile();
        }

        function deselectLetter(index) {
            const orderPos = selectedOrder.indexOf(index);
            if (orderPos === -1) return;

            // Only deselect the clicked letter
            letters[index].selected = false;
            letters[index].animating = true;

            // Remove from selectedOrder
            selectedOrder.splice(orderPos, 1);

            playLetterClick();
            updateWordPositions();
            updatePendingPile();
        }

        function updatePendingPile() {
            const word = getSelectedWord();
            const isValid = isValidWord(word);

            // Play sound when word becomes valid
            if (isValid && !lastWordValid) {
                playWordFound();
                // Preload item texture for this word
                loadItemTexture(word);
            }
            lastWordValid = isValid;

            if (isValid) {
                // Find an active pile to preview
                const activePiles = trashPiles.map((p, i) => ({ pile: p, index: i })).filter(p => p.pile.active);
                if (activePiles.length > 0) {
                    // Use a deterministic selection based on word (so it doesn't change while typing)
                    const hash = word.split('').reduce((acc, c) => acc + c.charCodeAt(0), 0);
                    const chosen = activePiles[hash % activePiles.length];
                    pendingPileIndex = chosen.index;

                    // Move camera to show the pending pile
                    const pile = trashPiles[pendingPileIndex];
                    targetCameraPos.set(pile.x, 6, pile.z - 15);
                    targetCameraLook.set(pile.x, 2, pile.z + 30);
                }
            } else {
                // No valid word - reset to default view
                pendingPileIndex = -1;
                targetCameraPos.set(0, 5, -10);
                targetCameraLook.set(0, 0, 50);
            }
        }

        // ============================================
        // UI RENDERING
        // ============================================
        function renderUI() {
            uiCtx.clearRect(0, 0, CONFIG.WIDTH, CONFIG.HEIGHT);

            // Increment animation time - frame independent
            animTime += 0.05 * deltaMultiplier;

            // Score at top of sky
            renderTopScore();

            renderLetterPool();
            renderWordArea();
            renderBottomUI();

            // Message
            if (messageTimer > 0) {
                const msgPadding = Math.floor(CONFIG.WIDTH * 0.125);
                const msgHeight = Math.floor(CONFIG.HEIGHT * 0.1);
                const msgFontSize = Math.max(14, Math.floor(CONFIG.WIDTH * 0.055));
                uiCtx.fillStyle = 'rgba(0,0,0,0.7)';
                uiCtx.fillRect(msgPadding, CONFIG.HEIGHT / 2 - msgHeight / 2, CONFIG.WIDTH - msgPadding * 2, msgHeight);
                uiCtx.fillStyle = '#FFF';
                uiCtx.font = `bold ${msgFontSize}px Arial`;
                uiCtx.textAlign = 'center';
                uiCtx.fillText(message, CONFIG.WIDTH / 2, CONFIG.HEIGHT / 2 + msgFontSize * 0.35);
            }

            // Fling indicator
            if (gameState === 'FLING' && flingStart && flingCurrent) {
                renderFlingIndicator();
            }

            if (showDictionary) {
                renderDictionaryPopup();
            }

            if (showQuitConfirm) {
                renderQuitConfirm();
            }

            if (gameState === 'VICTORY') {
                renderVictoryScreen();
            }

            // Floating score display
            renderFloatingScore();
        }

        function renderFloatingScore() {
            if (!floatingScore) return;

            const now = performance.now();
            const elapsed = now - floatingScore.startTime;
            const duration = 1500; // 1.5 seconds
            const progress = elapsed / duration;

            if (progress >= 1) {
                floatingScore = null;
                return;
            }

            // Project 3D position to 2D screen coordinates
            const pos3D = new THREE.Vector3(
                floatingScore.x,
                floatingScore.y + progress * 3, // Rise upward
                floatingScore.z
            );
            pos3D.project(camera);

            // Convert from normalized device coordinates to screen coordinates
            const screenX = (pos3D.x + 1) / 2 * CONFIG.WIDTH;
            const screenY = (1 - pos3D.y) / 2 * CONFIG.HEIGHT;

            // Don't render if behind camera
            if (pos3D.z > 1) return;

            // Fade out
            const opacity = 1 - progress;

            // Draw floating score
            const fontSize = Math.max(24, Math.floor(CONFIG.WIDTH * 0.08));
            const text = '+' + floatingScore.value;

            uiCtx.font = `bold ${fontSize}px Arial`;
            uiCtx.textAlign = 'center';
            uiCtx.textBaseline = 'middle';

            // Black outline
            uiCtx.strokeStyle = `rgba(0, 0, 0, ${opacity})`;
            uiCtx.lineWidth = 3;
            uiCtx.strokeText(text, screenX, screenY);

            // Gold fill
            uiCtx.fillStyle = `rgba(255, 215, 0, ${opacity})`;
            uiCtx.fillText(text, screenX, screenY);
        }

        function renderTopScore() {
            // Proportional positioning
            const topY = Math.floor(CONFIG.HEIGHT * 0.053);
            const scoreFontSize = Math.max(20, Math.floor(CONFIG.WIDTH * 0.105));

            // Button dimensions (same for both buttons) - 15% smaller
            const btnWidth = Math.floor(CONFIG.WIDTH * 0.276);
            const btnHeight = Math.floor(CONFIG.HEIGHT * 0.057);
            const btnY = Math.floor(CONFIG.HEIGHT * 0.02);
            const cornerRadius = Math.floor(btnHeight * 0.2);
            const btnFontSize = Math.max(12, Math.floor(btnHeight * 0.45));
            const btnMargin = Math.floor(CONFIG.WIDTH * 0.025);

            // QUIT JOB button on left
            const quitBtnX = btnMargin;

            if (showQuitConfirm) {
                // Glowing effect when quit confirm is showing
                const glowIntensity = 0.4 + Math.sin(animTime * 2) * 0.2;
                uiCtx.shadowColor = `rgba(100, 200, 255, ${glowIntensity})`;
                uiCtx.shadowBlur = 15;

                uiCtx.fillStyle = 'rgba(0,0,0,0.4)';
                uiCtx.beginPath();
                uiCtx.roundRect(quitBtnX + 2, btnY + 2, btnWidth, btnHeight, cornerRadius);
                uiCtx.fill();

                uiCtx.fillStyle = '#4a90d9';
                uiCtx.beginPath();
                uiCtx.roundRect(quitBtnX, btnY, btnWidth, btnHeight, cornerRadius);
                uiCtx.fill();

                uiCtx.strokeStyle = '#6ab0f9';
                uiCtx.lineWidth = 2;
                uiCtx.beginPath();
                uiCtx.roundRect(quitBtnX, btnY, btnWidth, btnHeight, cornerRadius);
                uiCtx.stroke();

                uiCtx.shadowColor = 'transparent';
                uiCtx.shadowBlur = 0;
            } else {
                uiCtx.fillStyle = 'rgba(0,0,0,0.4)';
                uiCtx.beginPath();
                uiCtx.roundRect(quitBtnX + 2, btnY + 2, btnWidth, btnHeight, cornerRadius);
                uiCtx.fill();

                uiCtx.fillStyle = '#555';
                uiCtx.beginPath();
                uiCtx.roundRect(quitBtnX, btnY, btnWidth, btnHeight, cornerRadius);
                uiCtx.fill();

                uiCtx.strokeStyle = '#888';
                uiCtx.lineWidth = 2;
                uiCtx.beginPath();
                uiCtx.roundRect(quitBtnX, btnY, btnWidth, btnHeight, cornerRadius);
                uiCtx.stroke();
            }

            uiCtx.fillStyle = '#FFF';
            uiCtx.font = `bold ${btnFontSize}px Arial`;
            uiCtx.textAlign = 'center';
            uiCtx.textBaseline = 'middle';
            uiCtx.fillText('QUIT JOB', quitBtnX + btnWidth / 2, btnY + btnHeight / 2);

            // Score in center with wave animation on digits
            const scoreStr = score.toString();
            uiCtx.font = `bold ${scoreFontSize}px Arial`;
            uiCtx.textAlign = 'center';
            uiCtx.textBaseline = 'middle';

            // Calculate total score width for centering
            let totalScoreWidth = 0;
            for (let i = 0; i < scoreStr.length; i++) {
                totalScoreWidth += uiCtx.measureText(scoreStr[i]).width + 2;
            }
            totalScoreWidth -= 2;

            let xPos = CONFIG.WIDTH / 2 - totalScoreWidth / 2;
            uiCtx.textAlign = 'left';
            for (let i = 0; i < scoreStr.length; i++) {
                const digit = scoreStr[i];
                const waveOffset = Math.sin(animTime * 0.5 + i * 1.2) * 3;

                uiCtx.fillStyle = 'rgba(0,0,0,0.6)';
                uiCtx.fillText(digit, xPos + 3, topY + waveOffset + 3);
                uiCtx.fillText(digit, xPos + 2, topY + waveOffset + 2);

                uiCtx.fillStyle = '#FFD700';
                uiCtx.fillText(digit, xPos, topY + waveOffset);

                xPos += uiCtx.measureText(digit).width + 2;
            }

            // Dictionary button on right
            const dictBtnX = CONFIG.WIDTH - btnWidth - btnMargin;

            if (showDictionary) {
                const glowIntensity = 0.4 + Math.sin(animTime * 2) * 0.2;
                uiCtx.shadowColor = `rgba(100, 200, 255, ${glowIntensity})`;
                uiCtx.shadowBlur = 15;

                uiCtx.fillStyle = 'rgba(0,0,0,0.4)';
                uiCtx.beginPath();
                uiCtx.roundRect(dictBtnX + 2, btnY + 2, btnWidth, btnHeight, cornerRadius);
                uiCtx.fill();

                uiCtx.fillStyle = '#4a90d9';
                uiCtx.beginPath();
                uiCtx.roundRect(dictBtnX, btnY, btnWidth, btnHeight, cornerRadius);
                uiCtx.fill();

                uiCtx.strokeStyle = '#6ab0f9';
                uiCtx.lineWidth = 2;
                uiCtx.beginPath();
                uiCtx.roundRect(dictBtnX, btnY, btnWidth, btnHeight, cornerRadius);
                uiCtx.stroke();

                uiCtx.shadowColor = 'transparent';
                uiCtx.shadowBlur = 0;
            } else {
                uiCtx.fillStyle = 'rgba(0,0,0,0.4)';
                uiCtx.beginPath();
                uiCtx.roundRect(dictBtnX + 2, btnY + 2, btnWidth, btnHeight, cornerRadius);
                uiCtx.fill();

                uiCtx.fillStyle = '#555';
                uiCtx.beginPath();
                uiCtx.roundRect(dictBtnX, btnY, btnWidth, btnHeight, cornerRadius);
                uiCtx.fill();

                uiCtx.strokeStyle = '#888';
                uiCtx.lineWidth = 2;
                uiCtx.beginPath();
                uiCtx.roundRect(dictBtnX, btnY, btnWidth, btnHeight, cornerRadius);
                uiCtx.stroke();
            }

            uiCtx.fillStyle = '#FFF';
            uiCtx.font = `bold ${btnFontSize}px Arial`;
            uiCtx.textAlign = 'center';
            uiCtx.textBaseline = 'middle';
            uiCtx.fillText('DICTIONARY', dictBtnX + btnWidth / 2, btnY + btnHeight / 2);
        }

        function renderLetterPool() {
            for (let i = 0; i < letters.length; i++) {
                const letter = letters[i];
                if (letter.selected) continue;
                if (!letter.revealed) continue; // Don't render unrevealed letters

                const size = letter.currentSize || CONFIG.LETTER_SIZE;
                const fontSize = Math.floor(size * 0.6);

                const x = letter.currentX;
                const y = letter.currentY;

                // Shadow for depth
                uiCtx.fillStyle = 'rgba(0, 0, 0, 0.4)';
                uiCtx.fillRect(x + 2, y + 2, size, size);

                // Box
                uiCtx.fillStyle = '#4a90d9';
                uiCtx.fillRect(x, y, size, size);

                uiCtx.strokeStyle = '#2a5a89';
                uiCtx.lineWidth = 2;
                uiCtx.strokeRect(x, y, size, size);

                // Letter with shadow
                uiCtx.font = `bold ${fontSize}px Arial`;
                uiCtx.textAlign = 'center';
                uiCtx.textBaseline = 'middle';

                uiCtx.fillStyle = 'rgba(0,0,0,0.3)';
                uiCtx.fillText(letter.char, x + size / 2 + 1, y + size / 2 + 1);

                uiCtx.fillStyle = '#FFF';
                uiCtx.fillText(letter.char, x + size / 2, y + size / 2);
            }
        }

        function renderWordArea() {
            const word = getSelectedWord();
            const isValid = isValidWord(word);
            const size = CONFIG.WORD_LETTER_SIZE;
            const fontSize = Math.floor(size * 0.6);

            for (let orderIndex = 0; orderIndex < selectedOrder.length; orderIndex++) {
                const letterIndex = selectedOrder[orderIndex];
                const letter = letters[letterIndex];

                const x = letter.currentX;
                const y = letter.currentY;

                // Shadow for depth
                uiCtx.fillStyle = 'rgba(0, 0, 0, 0.4)';
                uiCtx.fillRect(x + 2, y + 2, size, size);

                // Box
                uiCtx.fillStyle = isValid ? '#3d8a3d' : '#5a5a6a';
                uiCtx.fillRect(x, y, size, size);
                uiCtx.strokeStyle = isValid ? '#2d6a2d' : '#3a3a4a';
                uiCtx.lineWidth = 2;
                uiCtx.strokeRect(x, y, size, size);

                // Letter with shadow
                uiCtx.font = `bold ${fontSize}px Arial`;
                uiCtx.textAlign = 'center';
                uiCtx.textBaseline = 'middle';

                uiCtx.fillStyle = 'rgba(0,0,0,0.3)';
                uiCtx.fillText(letter.char, x + size / 2 + 1, y + size / 2 + 1);

                uiCtx.fillStyle = '#FFF';
                uiCtx.fillText(letter.char, x + size / 2, y + size / 2);
            }

            if (isValid && gameState === 'WORD_BUILDING') {
                // Button size proportional to screen width
                const baseBtnWidth = Math.floor(CONFIG.WIDTH * 0.4); // 40% of width
                const baseBtnHeight = Math.floor(baseBtnWidth * 0.3125); // Maintain aspect ratio
                const btnGap = Math.floor(CONFIG.HEIGHT * 0.03); // Gap below word letters
                const cornerRadius = Math.floor(baseBtnHeight * 0.2);

                // Pulsing animation - slower (half speed)
                const pulseScale = 1 + Math.sin(animTime * 2) * 0.03;
                const btnWidth = baseBtnWidth * pulseScale;
                const btnHeight = baseBtnHeight * pulseScale;
                const btnX = (CONFIG.WIDTH - btnWidth) / 2;
                const btnY = CONFIG.WORD_Y + size + btnGap - (btnHeight - baseBtnHeight) / 2;

                // Glow effect - subtler
                const glowIntensity = 0.2 + Math.sin(animTime * 2) * 0.1;
                uiCtx.shadowColor = `rgba(76, 175, 80, ${glowIntensity})`;
                uiCtx.shadowBlur = Math.floor(baseBtnHeight * 0.24) + Math.sin(animTime * 2) * 4;

                // Button shadow
                uiCtx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                uiCtx.beginPath();
                uiCtx.roundRect(btnX + 3, btnY + 3, btnWidth, btnHeight, cornerRadius);
                uiCtx.fill();

                // Button gradient
                const gradient = uiCtx.createLinearGradient(btnX, btnY, btnX, btnY + btnHeight);
                gradient.addColorStop(0, '#5CBF60');
                gradient.addColorStop(0.5, '#4CAF50');
                gradient.addColorStop(1, '#3D8B40');
                uiCtx.fillStyle = gradient;
                uiCtx.beginPath();
                uiCtx.roundRect(btnX, btnY, btnWidth, btnHeight, cornerRadius);
                uiCtx.fill();

                // Reset shadow
                uiCtx.shadowColor = 'transparent';
                uiCtx.shadowBlur = 0;

                // Border
                uiCtx.strokeStyle = '#2d7a2d';
                uiCtx.lineWidth = Math.max(2, Math.floor(baseBtnHeight * 0.06));
                uiCtx.beginPath();
                uiCtx.roundRect(btnX, btnY, btnWidth, btnHeight, cornerRadius);
                uiCtx.stroke();

                // Highlight
                uiCtx.fillStyle = 'rgba(255,255,255,0.2)';
                uiCtx.beginPath();
                uiCtx.roundRect(btnX + 4, btnY + 4, btnWidth - 8, btnHeight / 2 - 4, Math.max(2, cornerRadius - 4));
                uiCtx.fill();

                // Text - proportional to button
                const baseFontSize = Math.floor(baseBtnHeight * 0.44);
                const fontSize = Math.floor(baseFontSize * pulseScale);
                uiCtx.font = `bold ${fontSize}px Arial`;
                uiCtx.textAlign = 'center';
                uiCtx.textBaseline = 'middle';
                uiCtx.fillStyle = 'rgba(0,0,0,0.3)';
                uiCtx.fillText('THROW IT!', CONFIG.WIDTH / 2 + 1, btnY + btnHeight / 2 + 1);
                uiCtx.fillStyle = '#FFF';
                uiCtx.fillText('THROW IT!', CONFIG.WIDTH / 2, btnY + btnHeight / 2);
            }
        }

        function renderBottomUI() {
            // Show dialog box instead of tidiness when dialog is active
            if (dialogActive) {
                renderDialogBox();
                return;
            }

            const pilesCleared = CONFIG.PILE_COUNT - trashPiles.filter(p => p.active).length;

            // Calculate square size to fit available width (like letters do)
            const margin = 40; // 20px on each side
            const availableWidth = CONFIG.WIDTH - margin;
            const squareGap = Math.max(2, Math.floor(CONFIG.WIDTH / 100)); // Scale gap with width
            const squareSize = Math.floor((availableWidth - (CONFIG.PILE_COUNT - 1) * squareGap) / CONFIG.PILE_COUNT);

            const totalWidth = CONFIG.PILE_COUNT * squareSize + (CONFIG.PILE_COUNT - 1) * squareGap;
            const startX = (CONFIG.WIDTH - totalWidth) / 2;
            const squareY = CONFIG.HEIGHT - squareSize - 20;

            // Font size proportional to square size
            const labelFontSize = Math.max(12, Math.floor(squareSize * 0.9));

            // "TIDINESS" label - left aligned above progress bar
            uiCtx.font = `bold ${labelFontSize}px Arial`;
            uiCtx.textAlign = 'left';
            uiCtx.textBaseline = 'middle';
            // Strong black outline
            uiCtx.strokeStyle = 'black';
            uiCtx.lineWidth = 2;
            uiCtx.strokeText('TIDINESS', startX, squareY - squareSize * 0.7);
            uiCtx.fillStyle = '#FFD700'; // Gold like score
            uiCtx.fillText('TIDINESS', startX, squareY - squareSize * 0.7);

            // "WEIGHT X" label - right aligned at same level as TIDINESS
            let displayWeight = null;
            if (currentObject && currentObject.weight) {
                displayWeight = currentObject.weight;
            } else if (gameState === 'WORD_BUILDING') {
                const word = getSelectedWord();
                if (isValidWord(word)) {
                    displayWeight = DICTIONARY[word].weight;
                }
            }

            if (displayWeight !== null) {
                const endX = startX + totalWidth;
                const weightText = 'WEIGHT ' + displayWeight;
                uiCtx.font = `bold ${labelFontSize}px Arial`;
                uiCtx.textAlign = 'right';
                uiCtx.textBaseline = 'middle';
                // Strong black outline
                uiCtx.strokeStyle = 'black';
                uiCtx.lineWidth = 2;
                uiCtx.strokeText(weightText, endX, squareY - squareSize * 0.7);
                uiCtx.fillStyle = '#FFD700'; // Gold like score
                uiCtx.fillText(weightText, endX, squareY - squareSize * 0.7);
            }

            const cornerRadius = Math.max(2, Math.floor(squareSize / 4));

            for (let i = 0; i < CONFIG.PILE_COUNT; i++) {
                const x = startX + i * (squareSize + squareGap);
                const isFilled = i < pilesCleared;

                // Shadow
                uiCtx.fillStyle = 'rgba(0,0,0,0.3)';
                uiCtx.beginPath();
                uiCtx.roundRect(x + 2, squareY + 2, squareSize, squareSize, cornerRadius);
                uiCtx.fill();

                if (isFilled) {
                    const hue = 120 + Math.sin(animTime * 0.5 + i * 0.15) * 10;
                    const lightness = 50 + Math.sin(animTime * 0.7 + i * 0.2) * 5;
                    uiCtx.fillStyle = `hsl(${hue}, 60%, ${lightness}%)`;
                } else {
                    uiCtx.fillStyle = 'rgba(60, 60, 60, 0.8)';
                }

                uiCtx.beginPath();
                uiCtx.roundRect(x, squareY, squareSize, squareSize, cornerRadius);
                uiCtx.fill();

                if (isFilled) {
                    uiCtx.fillStyle = 'rgba(255,255,255,0.2)';
                    uiCtx.beginPath();
                    uiCtx.roundRect(x + 3, squareY + 3, squareSize - 6, squareSize / 2 - 2, Math.max(1, cornerRadius - 2));
                    uiCtx.fill();
                }
            }

            // Show "SLIDE DOWN TO SHOOT" hint on first shot
            if (gameState === 'FLING' && shotsTaken === 0 && !hasShownShootHint) {
                const hintFontSize = Math.max(14, Math.floor(CONFIG.WIDTH * 0.045));
                const hintY = squareY - squareSize * 1.8;

                // Pulsing opacity
                const pulseAlpha = 0.6 + Math.sin(animTime * 3) * 0.3;

                uiCtx.font = `bold ${hintFontSize}px Arial`;
                uiCtx.textAlign = 'center';
                uiCtx.textBaseline = 'middle';

                // Shadow
                uiCtx.fillStyle = `rgba(0, 0, 0, ${pulseAlpha * 0.5})`;
                uiCtx.fillText(' SLIDE DOWN TO SHOOT ', CONFIG.WIDTH / 2 + 1, hintY + 1);

                // Text
                uiCtx.fillStyle = `rgba(255, 200, 100, ${pulseAlpha})`;
                uiCtx.fillText(' SLIDE DOWN TO SHOOT ', CONFIG.WIDTH / 2, hintY);
            }
        }

        function renderDialogBox() {
            // Scale dialog box proportionally to screen size - increased by 10%
            const boxHeight = Math.floor(CONFIG.HEIGHT * 0.132); // ~13.2% of height (was 12%)
            const boxMargin = Math.floor(CONFIG.WIDTH * 0.025); // 2.5% margin
            const boxY = CONFIG.HEIGHT - boxHeight - boxMargin;
            const boxX = boxMargin;
            const boxWidth = CONFIG.WIDTH - boxMargin * 2;
            const cornerRadius = Math.floor(boxHeight * 0.12);

            // Box background
            uiCtx.fillStyle = 'rgba(20, 30, 40, 0.95)';
            uiCtx.beginPath();
            uiCtx.roundRect(boxX, boxY, boxWidth, boxHeight, cornerRadius);
            uiCtx.fill();

            // Box border
            uiCtx.strokeStyle = 'rgba(100, 140, 180, 0.6)';
            uiCtx.lineWidth = 2;
            uiCtx.beginPath();
            uiCtx.roundRect(boxX, boxY, boxWidth, boxHeight, cornerRadius);
            uiCtx.stroke();

            // Profile picture - proportional to box height
            const picSize = Math.floor(boxHeight * 0.65);
            const picMargin = Math.floor(boxHeight * 0.12);
            const picX = boxX + picMargin;
            const picY = boxY + (boxHeight - picSize) / 2; // Vertically center the pic
            const picRadius = Math.floor(picSize * 0.12);

            // Draw boss avatar or placeholder
            if (bossAvatarImage) {
                // Clip to rounded rect for the avatar
                uiCtx.save();
                uiCtx.beginPath();
                uiCtx.roundRect(picX, picY, picSize, picSize, picRadius);
                uiCtx.clip();
                uiCtx.drawImage(bossAvatarImage, picX, picY, picSize, picSize);
                uiCtx.restore();
            } else {
                // Fallback placeholder
                uiCtx.fillStyle = 'rgba(80, 100, 120, 0.8)';
                uiCtx.beginPath();
                uiCtx.roundRect(picX, picY, picSize, picSize, picRadius);
                uiCtx.fill();
            }

            // Border around avatar
            uiCtx.strokeStyle = 'rgba(120, 150, 180, 0.8)';
            uiCtx.lineWidth = 2;
            uiCtx.beginPath();
            uiCtx.roundRect(picX, picY, picSize, picSize, picRadius);
            uiCtx.stroke();

            // "BOSS" title - font size proportional to box
            const titleFontSize = Math.max(10, Math.floor(boxHeight * 0.16));
            const textX = picX + picSize + picMargin;
            const textAreaWidth = boxWidth - picSize - picMargin * 3;
            uiCtx.font = `bold ${titleFontSize}px Arial`;
            uiCtx.textAlign = 'left';
            uiCtx.textBaseline = 'top';
            uiCtx.fillStyle = '#FFD700';
            const textStartY = boxY + picMargin;
            uiCtx.fillText('BOSS', textX, textStartY);

            // Dialog text (character by character) with word wrapping
            if (dialogLines.length > 0 && currentDialogLine < dialogLines.length) {
                const fullLine = dialogLines[currentDialogLine];
                const displayText = fullLine.substring(0, currentDialogChar);

                const dialogFontSize = Math.max(11, Math.floor(boxHeight * 0.17));
                const lineHeight = dialogFontSize * 1.3;
                uiCtx.font = `${dialogFontSize}px Arial`;
                uiCtx.fillStyle = '#FFF';
                uiCtx.textBaseline = 'top';

                // Word wrap the text
                const words = displayText.split(' ');
                let lines = [];
                let currentLine = '';

                for (const word of words) {
                    const testLine = currentLine ? currentLine + ' ' + word : word;
                    const metrics = uiCtx.measureText(testLine);

                    if (metrics.width > textAreaWidth && currentLine) {
                        lines.push(currentLine);
                        currentLine = word;
                    } else {
                        currentLine = testLine;
                    }
                }
                if (currentLine) {
                    lines.push(currentLine);
                }

                // Limit to 2 lines max
                lines = lines.slice(0, 2);

                // Draw each line - add a bit more gap below BOSS title
                const titleGap = Math.max(9, Math.floor(boxHeight * 0.09));
                const dialogStartY = textStartY + titleFontSize + titleGap;
                lines.forEach((line, index) => {
                    uiCtx.fillText(line, textX, dialogStartY + index * lineHeight);
                });
            }
        }

        function renderFlingIndicator() {
            const pullX = flingCurrent.x - flingStart.x;
            const pullY = flingCurrent.y - flingStart.y;
            const rawPull = Math.sqrt(pullX * pullX + pullY * pullY);

            // Only show indicator when pulling down (forward throw)
            if (pullY <= 0) {
                return;
            }

            // Linear power scaling for precise control at low power
            // Max raw pull proportional to screen height
            const maxRawPull = CONFIG.HEIGHT * 0.4;
            const power = Math.min(100, Math.max(1, Math.round(100 * rawPull / maxRawPull)));

            // Scale visual elements proportionally
            const lineWidth = Math.max(1, Math.floor(CONFIG.WIDTH * 0.005));
            const arrowSize = Math.floor(CONFIG.WIDTH * 0.03);
            const fontSize = Math.max(12, Math.floor(CONFIG.WIDTH * 0.04));

            // Pull line (where finger dragged)
            uiCtx.strokeStyle = 'rgba(255, 200, 100, 0.6)';
            uiCtx.lineWidth = lineWidth;
            uiCtx.setLineDash([5, 5]);
            uiCtx.beginPath();
            uiCtx.moveTo(flingStart.x, flingStart.y);
            uiCtx.lineTo(flingCurrent.x, flingCurrent.y);
            uiCtx.stroke();
            uiCtx.setLineDash([]);

            // Throw direction indicator - always points UP (forward into screen)
            const throwLength = Math.max(arrowSize * 0.5, power * arrowSize * 0.05);
            const throwEndX = flingStart.x;
            const throwEndY = flingStart.y - throwLength;

            uiCtx.strokeStyle = `rgba(255, 80, 80, ${0.5 + power / 200})`;
            uiCtx.lineWidth = lineWidth * 2 + power / 25;
            uiCtx.lineCap = 'round';

            uiCtx.beginPath();
            uiCtx.moveTo(flingStart.x, flingStart.y);
            uiCtx.lineTo(throwEndX, throwEndY);
            uiCtx.stroke();

            // Arrowhead pointing up
            uiCtx.beginPath();
            uiCtx.moveTo(throwEndX, throwEndY);
            uiCtx.lineTo(throwEndX - arrowSize, throwEndY + arrowSize * 1.25);
            uiCtx.moveTo(throwEndX, throwEndY);
            uiCtx.lineTo(throwEndX + arrowSize, throwEndY + arrowSize * 1.25);
            uiCtx.stroke();

            // Power indicator
            uiCtx.font = `bold ${fontSize}px Arial`;
            uiCtx.textAlign = 'center';
            uiCtx.textBaseline = 'bottom';
            uiCtx.fillStyle = 'rgba(0,0,0,0.5)';
            uiCtx.fillText(`${Math.round(power)}%`, flingStart.x + 1, throwEndY - fontSize * 0.5);
            uiCtx.fillStyle = '#FFF';
            uiCtx.fillText(`${Math.round(power)}%`, flingStart.x, throwEndY - fontSize * 0.5 - 1);
        }

        function renderDictionaryPopup() {
            // Calculate button gap to know where dictionary starts
            const btnGap = Math.floor(CONFIG.HEIGHT * 0.03);
            const baseBtnHeight = Math.floor(CONFIG.WIDTH * 0.4 * 0.3125);

            // Dictionary starts below word letters and THROW IT button
            const dictStartY = CONFIG.WORD_Y + CONFIG.WORD_LETTER_SIZE + btnGap + baseBtnHeight + Math.floor(CONFIG.HEIGHT * 0.02);

            // Calculate available height for dictionary
            // Leave space for bottom UI (tidiness bar)
            const bottomMargin = Math.floor(CONFIG.HEIGHT * 0.12); // Reserve 12% for bottom UI
            const availableHeight = CONFIG.HEIGHT - dictStartY - bottomMargin;

            // Row height proportional to available space, aim for ~8 visible rows
            const targetVisibleRows = 8;
            const rowHeight = Math.floor(availableHeight / targetVisibleRows);
            const dictHeight = availableHeight;

            const margin = Math.floor(CONFIG.WIDTH * 0.0125); // Small margin
            const cornerRadius = Math.floor(CONFIG.WIDTH * 0.03);

            // Lighter background
            uiCtx.fillStyle = 'rgba(30, 40, 50, 0.95)';
            uiCtx.beginPath();
            uiCtx.roundRect(margin, dictStartY, CONFIG.WIDTH - margin * 2, dictHeight, cornerRadius);
            uiCtx.fill();

            // Border
            uiCtx.strokeStyle = 'rgba(100, 120, 140, 0.5)';
            uiCtx.lineWidth = 2;
            uiCtx.beginPath();
            uiCtx.roundRect(margin, dictStartY, CONFIG.WIDTH - margin * 2, dictHeight, cornerRadius);
            uiCtx.stroke();

            // Build word list: pre-selected words first, then rest
            const preSelectedSorted = preSelectedWords.slice().sort((a, b) => a.localeCompare(b));
            const otherWords = WORD_LIST.filter(w => !preSelectedWords.includes(w)).sort((a, b) => a.localeCompare(b));
            const allWords = [...preSelectedSorted, ...otherWords];

            const padding = Math.floor(CONFIG.WIDTH * 0.025);
            const startY = dictStartY + padding;
            const listHeight = dictHeight - padding * 2;
            const visibleRows = Math.floor(listHeight / rowHeight);
            const maxScroll = Math.max(0, allWords.length - visibleRows);

            // Scrollbar dimensions - proportional
            const scrollbarWidth = Math.floor(CONFIG.WIDTH * 0.06);
            const scrollbarX = CONFIG.WIDTH - scrollbarWidth - margin - padding;
            const trackY = startY + padding;
            const trackHeight = listHeight - padding * 2;

            // Clamp scroll
            dictScrollY = Math.max(0, Math.min(dictScrollY, maxScroll));

            const startIndex = Math.floor(dictScrollY);
            const endIndex = Math.min(startIndex + visibleRows + 1, allWords.length);

            // List area
            const listX = margin + padding;
            const listWidth = CONFIG.WIDTH - scrollbarWidth - margin * 2 - padding * 3;

            // Font size proportional to row height
            const wordFontSize = Math.max(12, Math.floor(rowHeight * 0.5));

            // Weight box size proportional to row height
            const boxSize = Math.max(8, Math.floor(rowHeight * 0.27));
            const boxGap = Math.max(2, Math.floor(boxSize * 0.3));

            uiCtx.save();
            uiCtx.beginPath();
            uiCtx.rect(0, startY, CONFIG.WIDTH, listHeight);
            uiCtx.clip();

            for (let i = startIndex; i < endIndex; i++) {
                const word = allWords[i];
                const y = startY + (i - dictScrollY) * rowHeight;
                const isPreSelected = preSelectedWords.includes(word);

                // Row background
                if (isPreSelected) {
                    uiCtx.fillStyle = 'rgba(60, 140, 60, 0.3)';
                    uiCtx.fillRect(listX, y, listWidth, rowHeight - 2);
                } else if (i % 2 === 0) {
                    uiCtx.fillStyle = 'rgba(255, 255, 255, 0.06)';
                    uiCtx.fillRect(listX, y, listWidth, rowHeight - 2);
                }

                // Word name - left aligned
                const hue = 40 + word.length * 20;
                uiCtx.font = `bold ${wordFontSize}px Arial`;
                uiCtx.fillStyle = isPreSelected ? '#8f8' : `hsl(${hue}, 70%, 70%)`;
                uiCtx.textAlign = 'left';
                uiCtx.textBaseline = 'middle';
                uiCtx.fillText(word, listX + padding, y + rowHeight / 2);

                // Weight boxes
                const weight = DICTIONARY[word].weight;
                const weightX = listX + listWidth - padding;

                for (let w = 0; w < 8; w++) {
                    const bx = weightX - (8 - w) * (boxSize + boxGap);
                    const by = y + rowHeight / 2 - boxSize / 2;

                    if (w < weight) {
                        const wHue = 120 - weight * 12;
                        uiCtx.fillStyle = `hsl(${wHue}, 65%, 55%)`;
                    } else {
                        uiCtx.fillStyle = 'rgba(255,255,255,0.1)';
                    }

                    uiCtx.beginPath();
                    uiCtx.roundRect(bx, by, boxSize, boxSize, Math.max(1, Math.floor(boxSize * 0.2)));
                    uiCtx.fill();
                }
            }

            uiCtx.restore();

            // Scrollbar track
            uiCtx.fillStyle = 'rgba(255, 255, 255, 0.12)';
            uiCtx.beginPath();
            uiCtx.roundRect(scrollbarX, trackY, scrollbarWidth, trackHeight, scrollbarWidth / 2);
            uiCtx.fill();

            // Scrollbar thumb
            if (allWords.length > visibleRows) {
                const thumbHeight = Math.max(Math.floor(CONFIG.HEIGHT * 0.08), (visibleRows / allWords.length) * trackHeight);
                const thumbY = trackY + (dictScrollY / maxScroll) * (trackHeight - thumbHeight);

                const gradient = uiCtx.createLinearGradient(scrollbarX, 0, scrollbarX + scrollbarWidth, 0);
                gradient.addColorStop(0, '#666');
                gradient.addColorStop(0.5, '#888');
                gradient.addColorStop(1, '#666');
                uiCtx.fillStyle = gradient;
                uiCtx.beginPath();
                uiCtx.roundRect(scrollbarX, thumbY, scrollbarWidth, thumbHeight, scrollbarWidth / 2);
                uiCtx.fill();

                uiCtx.fillStyle = 'rgba(255,255,255,0.2)';
                uiCtx.beginPath();
                uiCtx.roundRect(scrollbarX + 3, thumbY + 3, scrollbarWidth - 6, thumbHeight - 6, (scrollbarWidth - 6) / 2);
                uiCtx.fill();

                renderDictionaryPopup.scrollbar = {
                    x: scrollbarX,
                    y: trackY,
                    width: scrollbarWidth,
                    height: trackHeight,
                    thumbY: thumbY,
                    thumbHeight: thumbHeight,
                    maxScroll: maxScroll
                };
            }
        }

        function renderQuitConfirm() {
            // Semi-transparent overlay
            uiCtx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            uiCtx.fillRect(0, 0, CONFIG.WIDTH, CONFIG.HEIGHT);

            // Dialog box at bottom (same style as intro dialog)
            const boxHeight = Math.floor(CONFIG.HEIGHT * 0.132);
            const boxMargin = Math.floor(CONFIG.WIDTH * 0.025);
            const boxY = CONFIG.HEIGHT - boxHeight - boxMargin;
            const boxX = boxMargin;
            const boxWidth = CONFIG.WIDTH - boxMargin * 2;
            const cornerRadius = Math.floor(boxHeight * 0.12);

            // Box background
            uiCtx.fillStyle = 'rgba(20, 30, 40, 0.95)';
            uiCtx.beginPath();
            uiCtx.roundRect(boxX, boxY, boxWidth, boxHeight, cornerRadius);
            uiCtx.fill();

            // Box border
            uiCtx.strokeStyle = 'rgba(100, 140, 180, 0.6)';
            uiCtx.lineWidth = 2;
            uiCtx.beginPath();
            uiCtx.roundRect(boxX, boxY, boxWidth, boxHeight, cornerRadius);
            uiCtx.stroke();

            // Profile picture
            const picSize = Math.floor(boxHeight * 0.65);
            const picMargin = Math.floor(boxHeight * 0.12);
            const picX = boxX + picMargin;
            const picY = boxY + (boxHeight - picSize) / 2;
            const picRadius = Math.floor(picSize * 0.12);

            if (bossAvatarImage) {
                uiCtx.save();
                uiCtx.beginPath();
                uiCtx.roundRect(picX, picY, picSize, picSize, picRadius);
                uiCtx.clip();
                uiCtx.drawImage(bossAvatarImage, picX, picY, picSize, picSize);
                uiCtx.restore();
            } else {
                uiCtx.fillStyle = 'rgba(80, 100, 120, 0.8)';
                uiCtx.beginPath();
                uiCtx.roundRect(picX, picY, picSize, picSize, picRadius);
                uiCtx.fill();
            }

            uiCtx.strokeStyle = 'rgba(120, 150, 180, 0.8)';
            uiCtx.lineWidth = 2;
            uiCtx.beginPath();
            uiCtx.roundRect(picX, picY, picSize, picSize, picRadius);
            uiCtx.stroke();

            // "BOSS" title
            const titleFontSize = Math.max(10, Math.floor(boxHeight * 0.16));
            const textX = picX + picSize + picMargin;
            uiCtx.font = `bold ${titleFontSize}px Arial`;
            uiCtx.textAlign = 'left';
            uiCtx.textBaseline = 'top';
            uiCtx.fillStyle = '#FFD700';
            const textStartY = boxY + picMargin;
            uiCtx.fillText('BOSS', textX, textStartY);

            // Dialog text
            const dialogFontSize = Math.max(11, Math.floor(boxHeight * 0.17));
            uiCtx.font = `${dialogFontSize}px Arial`;
            uiCtx.fillStyle = '#FFF';
            const titleGap = Math.max(9, Math.floor(boxHeight * 0.09));
            const dialogY = textStartY + titleFontSize + titleGap;
            const displayName = playerName || 'Worker';
            uiCtx.fillText(`${displayName}! Do you really want to quit?`, textX, dialogY);
            uiCtx.fillText(`There's more work to do...`, textX, dialogY + dialogFontSize * 1.3);

            // QUIT and STAY buttons in center of screen
            const btnWidth = Math.floor(CONFIG.WIDTH * 0.35);
            const btnHeight = Math.floor(CONFIG.HEIGHT * 0.08);
            const btnGap = Math.floor(CONFIG.WIDTH * 0.05);
            const btnY = CONFIG.HEIGHT * 0.45;
            const btnCornerRadius = Math.floor(btnHeight * 0.2);
            const btnFontSize = Math.max(14, Math.floor(btnHeight * 0.4));

            // QUIT button (left, red-ish)
            const quitX = CONFIG.WIDTH / 2 - btnWidth - btnGap / 2;

            uiCtx.fillStyle = 'rgba(0,0,0,0.4)';
            uiCtx.beginPath();
            uiCtx.roundRect(quitX + 2, btnY + 2, btnWidth, btnHeight, btnCornerRadius);
            uiCtx.fill();

            uiCtx.fillStyle = '#8B3A3A';
            uiCtx.beginPath();
            uiCtx.roundRect(quitX, btnY, btnWidth, btnHeight, btnCornerRadius);
            uiCtx.fill();

            uiCtx.strokeStyle = '#AA5555';
            uiCtx.lineWidth = 2;
            uiCtx.beginPath();
            uiCtx.roundRect(quitX, btnY, btnWidth, btnHeight, btnCornerRadius);
            uiCtx.stroke();

            uiCtx.fillStyle = '#FFF';
            uiCtx.font = `bold ${btnFontSize}px Arial`;
            uiCtx.textAlign = 'center';
            uiCtx.textBaseline = 'middle';
            uiCtx.fillText('QUIT', quitX + btnWidth / 2, btnY + btnHeight / 2);

            // STAY button (right, green-ish)
            const stayX = CONFIG.WIDTH / 2 + btnGap / 2;

            uiCtx.fillStyle = 'rgba(0,0,0,0.4)';
            uiCtx.beginPath();
            uiCtx.roundRect(stayX + 2, btnY + 2, btnWidth, btnHeight, btnCornerRadius);
            uiCtx.fill();

            uiCtx.fillStyle = '#3A6B3A';
            uiCtx.beginPath();
            uiCtx.roundRect(stayX, btnY, btnWidth, btnHeight, btnCornerRadius);
            uiCtx.fill();

            uiCtx.strokeStyle = '#55AA55';
            uiCtx.lineWidth = 2;
            uiCtx.beginPath();
            uiCtx.roundRect(stayX, btnY, btnWidth, btnHeight, btnCornerRadius);
            uiCtx.stroke();

            uiCtx.fillStyle = '#FFF';
            uiCtx.font = `bold ${btnFontSize}px Arial`;
            uiCtx.textAlign = 'center';
            uiCtx.textBaseline = 'middle';
            uiCtx.fillText('STAY', stayX + btnWidth / 2, btnY + btnHeight / 2);

            // Store button positions for click handling
            renderQuitConfirm.quitBtn = { x: quitX, y: btnY, width: btnWidth, height: btnHeight };
            renderQuitConfirm.stayBtn = { x: stayX, y: btnY, width: btnWidth, height: btnHeight };
        }

        function renderVictoryScreen() {
            // Skip rendering if in Remix (Remix handles its own game over UI)
            if (isInRemix()) return;

            uiCtx.fillStyle = 'rgba(0, 0, 0, 0.85)';
            uiCtx.fillRect(0, 0, CONFIG.WIDTH, CONFIG.HEIGHT);

            // Font sizes proportional to screen
            const titleFontSize = Math.floor(CONFIG.WIDTH * 0.08);
            const scoreFontSize = Math.floor(CONFIG.WIDTH * 0.07);
            const labelFontSize = Math.floor(CONFIG.WIDTH * 0.035);
            const infoFontSize = Math.floor(CONFIG.WIDTH * 0.045);

            uiCtx.fillStyle = '#FFD700';
            uiCtx.font = `bold ${titleFontSize}px Arial`;
            uiCtx.textAlign = 'center';
            uiCtx.textBaseline = 'middle';
            uiCtx.fillText('GARBIDUP', CONFIG.WIDTH / 2, CONFIG.HEIGHT * 0.3);
            uiCtx.fillText('CLEARED!', CONFIG.WIDTH / 2, CONFIG.HEIGHT * 0.3 + titleFontSize * 1.2);

            uiCtx.fillStyle = '#FFF';
            uiCtx.font = `${scoreFontSize}px Arial`;
            uiCtx.fillText(score.toString(), CONFIG.WIDTH / 2, CONFIG.HEIGHT * 0.5);
            uiCtx.font = `${labelFontSize}px Arial`;
            uiCtx.fillStyle = '#AAA';
            uiCtx.fillText('FINAL SCORE', CONFIG.WIDTH / 2, CONFIG.HEIGHT * 0.5 + scoreFontSize);

            uiCtx.fillStyle = '#FFF';
            uiCtx.font = `${infoFontSize}px Arial`;
            uiCtx.fillText(`Objects Flung: ${pilesCleared}`, CONFIG.WIDTH / 2, CONFIG.HEIGHT * 0.65);

            uiCtx.fillStyle = '#4CAF50';
            uiCtx.fillText('Tap to play again', CONFIG.WIDTH / 2, CONFIG.HEIGHT * 0.75);
        }

        // ============================================
        // INPUT HANDLING
        // ============================================
        function initInput() {
            uiCanvas.addEventListener('mousedown', handlePointerStart);
            uiCanvas.addEventListener('mousemove', handlePointerMove);
            uiCanvas.addEventListener('mouseup', handlePointerEnd);

            uiCanvas.addEventListener('touchstart', (e) => {
                e.preventDefault();
                handlePointerStart(e.touches[0]);
            });
            uiCanvas.addEventListener('touchmove', (e) => {
                e.preventDefault();
                handlePointerMove(e.touches[0]);
            });
            uiCanvas.addEventListener('touchend', (e) => {
                e.preventDefault();
                handlePointerEnd(e.changedTouches[0]);
            });

            // Mouse wheel for dictionary scroll
            uiCanvas.addEventListener('wheel', (e) => {
                if (showDictionary) {
                    e.preventDefault();
                    dictScrollY += e.deltaY * 0.02;
                }
            }, { passive: false });
        }

        function getCanvasCoords(event) {
            const rect = uiCanvas.getBoundingClientRect();
            const scaleX = CONFIG.WIDTH / rect.width;
            const scaleY = CONFIG.HEIGHT / rect.height;
            return {
                x: (event.clientX - rect.left) * scaleX,
                y: (event.clientY - rect.top) * scaleY
            };
        }

        // Dictionary scroll state
        let dictDragStart = null;
        let dictDragScrollStart = 0;
        let dictScrollbarDrag = false;

        function handlePointerStart(event) {
            const pos = getCanvasCoords(event);

            // Start music on first interaction (avoids autoplay blocking)
            startMusic();

            // During dialog, tapping advances or skips
            if (dialogActive && (gameState === 'INTRO' || gameState === 'TRANSITIONING')) {
                // If line is still typing, complete it instantly
                if (currentDialogChar < dialogLines[currentDialogLine].length) {
                    currentDialogChar = dialogLines[currentDialogLine].length;
                    dialogPauseTimer = 0;
                } else {
                    // Move to next line
                    currentDialogLine++;
                    currentDialogChar = 0;
                    dialogPauseTimer = 0;

                    if (currentDialogLine >= dialogLines.length) {
                        dialogActive = false;
                        if (gameState === 'INTRO') {
                            startLetterReveal();
                        } else if (gameState === 'TRANSITIONING') {
                            finishSuccessTransition();
                        }
                    }
                }
                return;
            }

            // During letter reveal, can't interact
            if (gameState === 'LETTER_REVEAL') {
                return;
            }

            // Handle quit confirm dialog buttons
            if (showQuitConfirm) {
                const quitBtn = renderQuitConfirm.quitBtn;
                const stayBtn = renderQuitConfirm.stayBtn;

                if (quitBtn && pos.x >= quitBtn.x && pos.x <= quitBtn.x + quitBtn.width &&
                    pos.y >= quitBtn.y && pos.y <= quitBtn.y + quitBtn.height) {
                    // QUIT - end game and submit score
                    showQuitConfirm = false;
                    gameState = 'VICTORY';
                    signalGameOver(score);
                    return;
                }

                if (stayBtn && pos.x >= stayBtn.x && pos.x <= stayBtn.x + stayBtn.width &&
                    pos.y >= stayBtn.y && pos.y <= stayBtn.y + stayBtn.height) {
                    // STAY - close dialog and resume
                    showQuitConfirm = false;
                    return;
                }

                // Clicking anywhere else also closes the dialog
                showQuitConfirm = false;
                return;
            }

            // Button dimensions (same for both buttons) - 15% smaller
            const btnWidth = Math.floor(CONFIG.WIDTH * 0.276);
            const btnHeight = Math.floor(CONFIG.HEIGHT * 0.057);
            const btnY = Math.floor(CONFIG.HEIGHT * 0.02);
            const btnMargin = Math.floor(CONFIG.WIDTH * 0.025);

            // QUIT JOB button - top left
            const quitBtnX = btnMargin;
            if (pos.x >= quitBtnX && pos.x <= quitBtnX + btnWidth &&
                pos.y >= btnY && pos.y <= btnY + btnHeight) {
                showQuitConfirm = true;
                showDictionary = false; // Close dictionary if open
                return;
            }

            // Dictionary button - top right
            const dictBtnX = CONFIG.WIDTH - btnWidth - btnMargin;

            if (pos.x >= dictBtnX && pos.x <= dictBtnX + btnWidth &&
                pos.y >= btnY && pos.y <= btnY + btnHeight) {
                showDictionary = !showDictionary; // Toggle dictionary
                playOpenDictionary();
                return;
            }

            // Check letter interactions (works even with dictionary open)
            if (gameState === 'WORD_BUILDING') {
                // Pool letters (anagram row)
                for (let i = 0; i < letters.length; i++) {
                    if (letters[i].selected) continue;
                    if (!letters[i].revealed) continue;
                    const letter = letters[i];
                    if (pos.x >= letter.currentX && pos.x <= letter.currentX + CONFIG.LETTER_SIZE &&
                        pos.y >= letter.currentY && pos.y <= letter.currentY + CONFIG.LETTER_SIZE) {
                        selectLetter(i);
                        return;
                    }
                }
            }

            // Submit button - check even with dictionary open (closes dictionary and submits)
            if (gameState === 'WORD_BUILDING') {
                const word = getSelectedWord();
                if (isValidWord(word)) {
                    // Use same proportional calculation as rendering
                    const btnWidth = Math.floor(CONFIG.WIDTH * 0.4);
                    const btnHeight = Math.floor(btnWidth * 0.3125);
                    const btnGap = Math.floor(CONFIG.HEIGHT * 0.03);
                    const btnX = (CONFIG.WIDTH - btnWidth) / 2;
                    const btnY = CONFIG.WORD_Y + CONFIG.WORD_LETTER_SIZE + btnGap;

                    if (pos.x >= btnX && pos.x <= btnX + btnWidth &&
                        pos.y >= btnY && pos.y <= btnY + btnHeight) {
                        submitWord(); // This closes dictionary automatically
                        return;
                    }
                }
            }

            if (showDictionary) {
                // Calculate dictionary start Y using same formula as rendering
                const btnGap = Math.floor(CONFIG.HEIGHT * 0.03);
                const baseBtnHeight = Math.floor(CONFIG.WIDTH * 0.4 * 0.3125);
                const dictStartY = CONFIG.WORD_Y + CONFIG.WORD_LETTER_SIZE + btnGap + baseBtnHeight + Math.floor(CONFIG.HEIGHT * 0.02);

                // Only interact with dictionary scrollbar if clicking within dictionary area
                if (pos.y >= dictStartY) {
                    const sb = renderDictionaryPopup.scrollbar;
                    if (sb && pos.x >= sb.x && pos.x <= sb.x + sb.width) {
                        if (pos.y >= sb.y && pos.y <= sb.y + sb.height) {
                            dictScrollbarDrag = true;
                            if (pos.y < sb.thumbY || pos.y > sb.thumbY + sb.thumbHeight) {
                                const clickRatio = (pos.y - sb.y) / sb.height;
                                dictScrollY = clickRatio * sb.maxScroll;
                            }
                            dictDragStart = pos.y;
                            dictDragScrollStart = dictScrollY;
                            return;
                        }
                    }

                    // Start drag scroll on list area
                    dictDragStart = pos.y;
                    dictDragScrollStart = dictScrollY;
                    dictScrollbarDrag = false;
                    return;
                }
                // Allow clicks above dictionary area to fall through to word letter handling
            }

            if (gameState === 'VICTORY') {
                resetGame();
                return;
            }

            if (gameState === 'WORD_BUILDING') {
                // Word area letters - use WORD_LETTER_SIZE for hit detection
                for (let orderIndex = selectedOrder.length - 1; orderIndex >= 0; orderIndex--) {
                    const letterIndex = selectedOrder[orderIndex];
                    const letter = letters[letterIndex];
                    const wordSize = CONFIG.WORD_LETTER_SIZE;
                    if (pos.x >= letter.currentX && pos.x <= letter.currentX + wordSize &&
                        pos.y >= letter.currentY && pos.y <= letter.currentY + wordSize) {
                        deselectLetter(letterIndex);
                        return;
                    }
                }
            }

            if (gameState === 'FLING') {
                flingStart = pos;
                flingCurrent = pos;
                isFlingReady = true;
            }
        }

        function handlePointerMove(event) {
            const pos = getCanvasCoords(event);

            if (showDictionary && dictDragStart !== null) {
                if (dictScrollbarDrag) {
                    // Dragging scrollbar thumb directly
                    const sb = renderDictionaryPopup.scrollbar;
                    if (sb) {
                        const deltaY = pos.y - dictDragStart;
                        const scrollRatio = deltaY / (sb.height - sb.thumbHeight);
                        dictScrollY = dictDragScrollStart + scrollRatio * sb.maxScroll;
                    }
                } else {
                    // Drag scroll in list area (inverted)
                    const deltaY = dictDragStart - pos.y;
                    const rowHeight = 52; // Match dictionary row height
                    dictScrollY = dictDragScrollStart + deltaY / rowHeight;
                }
            }

            if (gameState === 'FLING' && isFlingReady) {
                flingCurrent = pos;
            }
        }

        function handlePointerEnd(event) {
            const pos = getCanvasCoords(event);

            if (showDictionary) {
                const dictStartY = CONFIG.WORD_Y + CONFIG.WORD_LETTER_SIZE + 80;

                // Tap within dictionary area (not scrollbar drag) closes it
                if (dictDragStart !== null && !dictScrollbarDrag && pos.y >= dictStartY) {
                    const deltaY = Math.abs(dictDragStart - pos.y);
                    if (deltaY < 10) {
                        showDictionary = false;
                    }
                }
                dictDragStart = null;
                dictScrollbarDrag = false;
                return;
            }

            if (gameState === 'FLING' && isFlingReady && flingStart) {
                performFling(pos);
                flingStart = null;
                flingCurrent = null;
                isFlingReady = false;
            }
        }

        function submitWord() {
            const word = getSelectedWord();
            if (!isValidWord(word)) return;

            // Close dictionary if open
            showDictionary = false;

            const activePiles = trashPiles.map((p, i) => ({ pile: p, index: i })).filter(p => p.pile.active);
            if (activePiles.length === 0) {
                gameState = 'VICTORY';
                signalGameOver(score);
                return;
            }

            // Use the pending pile that was already shown in preview, or fall back to random
            let chosenIndex = pendingPileIndex;
            if (chosenIndex === -1 || !trashPiles[chosenIndex]?.active) {
                const hash = word.split('').reduce((acc, c) => acc + c.charCodeAt(0), 0);
                chosenIndex = activePiles[hash % activePiles.length].index;
            }

            activePileIndex = chosenIndex;
            const chosenPile = trashPiles[chosenIndex];

            currentObject = {
                word: word,
                weight: DICTIONARY[word].weight,
                x: chosenPile.x,
                y: 2,
                z: chosenPile.z,
                vx: 0,
                vy: 0,
                vz: 0,
                rotation: 0,
                rotationSpeed: 0
            };

            createObjectMesh(word, currentObject.weight);
            objectMesh.position.set(currentObject.x, currentObject.y, currentObject.z);

            // Highlight pile
            if (chosenPile.mesh) {
                chosenPile.mesh.children.forEach(child => {
                    if (child.material) {
                        child.userData.originalColor = child.material.color.getHex();
                        child.material.emissive = new THREE.Color(0x444400);
                    }
                });
            }

            shotsTaken = 0;
            trailPoints = [];
            updateTrail(); // Clear the trail line

            // Snap camera behind object
            cameraMode = 'DUMPYARD';
            setCameraBehindObject();

            gameState = 'OBJECT_SPAWN';
            pendingPileIndex = -1; // Reset pending pile

            setTimeout(() => {
                if (gameState === 'OBJECT_SPAWN') {
                    gameState = 'FLING';
                }
            }, 1000);
        }

        function performFling(endPos) {
            if (!currentObject) return;

            const pullX = endPos.x - flingStart.x;
            const pullY = endPos.y - flingStart.y;

            // Only accept downward pulls (forward throws)
            if (pullY <= 0) return;

            const rawPull = Math.sqrt(pullX * pullX + pullY * pullY);

            // Linear power scaling (matches indicator) - proportional to screen
            const maxRawPull = CONFIG.HEIGHT * 0.4;
            const clampedPull = Math.min(rawPull, maxRawPull);
            const normalizedPower = clampedPull / maxRawPull; // 0 to 1

            // Linear weight: weight 8 travels 1/8 as far as weight 1
            const weightFactor = 1 / currentObject.weight;

            const directionMultiplier = (cameraMode === 'DUMPYARD') ? 1 : -1;

            // Velocities tuned so weight 8 at 100% power can reach lake from back of dumpyard
            // Back of dumpyard: z  5, lake starts at z = 80 (LAKE_Z - LAKE_WIDTH/2 = 100 - 20)
            // Need ~75 units of travel for weight 8 at 100% power
            // Increased base velocity to ensure heavy items can reach
            currentObject.vz = normalizedPower * 8.0 * weightFactor * directionMultiplier;

            // Lateral velocity - normalized to screen width
            currentObject.vx = -pullX / CONFIG.WIDTH * 1.2 * weightFactor;

            // Vertical velocity for nice arc - increased for longer flight time
            currentObject.vy = 0.08 + normalizedPower * 0.9 * weightFactor;

            // Spin
            currentObject.rotationSpeed = (Math.random() - 0.5) * 0.08 + pullX / CONFIG.WIDTH * 0.12;

            trailPoints = [];
            shotsTaken++;

            // Start fading the trash pile on first shot (player has committed)
            if (shotsTaken === 1) {
                startPileFade(activePileIndex);
            }

            hasShownShootHint = true; // Hide the hint after first shot
            playThrowItem();
            gameState = 'FLYING';
        }

        // ============================================
        // GAME LOGIC
        // ============================================
        let lastUpdateTime = 0;
        let deltaMultiplier = 1; // Global so renderUI can access it
        const REFERENCE_FRAME_TIME = 1000 / 144; // 144fps reference (~6.944ms)

        function update() {
            // Skip updates when tab is hidden
            if (!isTabVisible) {
                return;
            }

            const now = performance.now();
            const deltaTime = lastUpdateTime ? now - lastUpdateTime : REFERENCE_FRAME_TIME;
            lastUpdateTime = now;
            deltaMultiplier = deltaTime / REFERENCE_FRAME_TIME; // 1.0 at 144fps, ~2.4 at 60fps

            // Update trash pile fade animations
            updatePileFades();
            updateFishAnimation();
            updateObjectFade();

            // Dialog animation
            if (dialogActive && dialogLines.length > 0) {
                if (currentDialogLine < dialogLines.length) {
                    const currentLine = dialogLines[currentDialogLine];

                    if (currentDialogChar < currentLine.length) {
                        // Reveal characters
                        dialogCharTimer += deltaTime;
                        if (dialogCharTimer >= DIALOG_CHAR_SPEED) {
                            dialogCharTimer = 0;
                            currentDialogChar++;
                            // Play type blip for non-space characters
                            const char = currentLine[currentDialogChar - 1];
                            if (char && char !== ' ') {
                                playTypeBlip();
                            }
                        }
                    } else {
                        // Line complete, wait then advance
                        dialogPauseTimer += deltaTime;
                        if (dialogPauseTimer >= DIALOG_PAUSE_TIME) {
                            dialogPauseTimer = 0;
                            currentDialogChar = 0;
                            currentDialogLine++;

                            // Check if dialog is done
                            if (currentDialogLine >= dialogLines.length) {
                                dialogActive = false;
                                // Start letter reveal animation after intro dialog
                                if (gameState === 'INTRO') {
                                    startLetterReveal();
                                } else if (gameState === 'TRANSITIONING') {
                                    // After success dialog, transition to next round
                                    finishSuccessTransition();
                                }
                            }
                        }
                    }
                }
            }

            // Letter reveal animation (80ms between each letter)
            if (letterAnimationQueue.length > 0) {
                letterAnimationTimer += deltaTime;
                if (letterAnimationTimer >= 80) {
                    letterAnimationTimer = 0;
                    const letterIndex = letterAnimationQueue.shift();
                    letters[letterIndex].revealed = true;
                    playLetterFlow();

                    // If all letters revealed, start game
                    if (letterAnimationQueue.length === 0) {
                        gameState = 'WORD_BUILDING';
                    }
                }
            }

            // Letter animations (position and size) - frame independent
            const animSpeed = 1 - Math.pow(1 - CONFIG.ANIM_SPEED, deltaMultiplier);
            for (let i = 0; i < letters.length; i++) {
                const letter = letters[i];
                if (!letter.revealed) continue;

                let targetX = letter.selected ? letter.wordX : letter.poolX;
                let targetY = letter.selected ? letter.wordY : letter.poolY;
                let targetSize = letter.selected ? CONFIG.WORD_LETTER_SIZE : CONFIG.LETTER_SIZE;

                letter.currentX += (targetX - letter.currentX) * animSpeed;
                letter.currentY += (targetY - letter.currentY) * animSpeed;
                letter.currentSize = letter.currentSize || 5;
                letter.currentSize += (targetSize - letter.currentSize) * animSpeed;
            }

            // Message timer - frame independent
            if (messageTimer > 0) {
                messageTimer -= deltaTime;
            }

            // Camera interpolation - frame independent
            const baseCameraLerpSpeed = (gameState === 'FLYING') ? 0.12 : 0.06;
            const cameraLerpSpeed = 1 - Math.pow(1 - baseCameraLerpSpeed, deltaMultiplier);
            camera.position.lerp(targetCameraPos, cameraLerpSpeed);

            // Smooth lookAt by interpolating a look target point
            if (!camera.userData.currentLookAt) {
                camera.userData.currentLookAt = targetCameraLook.clone();
            }
            camera.userData.currentLookAt.lerp(targetCameraLook, cameraLerpSpeed);
            camera.lookAt(camera.userData.currentLookAt);

            // Object physics - frame independent
            if (gameState === 'FLYING' && currentObject) {
                // Gravity - frame independent
                currentObject.vy -= CONFIG.GRAVITY * deltaMultiplier;

                // Air resistance - frame independent (use pow for correct behavior)
                const airResistance = Math.pow(CONFIG.AIR_RESISTANCE, deltaMultiplier);
                currentObject.vx *= airResistance;
                currentObject.vz *= airResistance;

                // Update position - frame independent
                currentObject.x += currentObject.vx * deltaMultiplier;
                currentObject.y += currentObject.vy * deltaMultiplier;
                currentObject.z += currentObject.vz * deltaMultiplier;
                currentObject.rotation += currentObject.rotationSpeed * deltaMultiplier;

                // Clamp position to stay within playable bounds
                const lakeStart = CONFIG.LAKE_Z - CONFIG.LAKE_WIDTH / 2;
                const lakeEnd = CONFIG.LAKE_Z + CONFIG.LAKE_WIDTH / 2;
                const minZ = -5;
                const maxZ = lakeEnd + 30; // Allow some overshoot into grass but not infinite
                const maxX = CONFIG.CORRIDOR_WIDTH / 2 - 2;

                // If object would go past bounds, clamp it and kill that velocity component
                if (currentObject.z < minZ) {
                    currentObject.z = minZ;
                    currentObject.vz = 0;
                } else if (currentObject.z > maxZ) {
                    currentObject.z = maxZ;
                    currentObject.vz = 0;
                }

                if (Math.abs(currentObject.x) > maxX) {
                    currentObject.x = Math.sign(currentObject.x) * maxX;
                    currentObject.vx = 0;
                }

                // Update mesh
                if (objectMesh) {
                    objectMesh.position.set(currentObject.x, currentObject.y, currentObject.z);

                    // Apply rotation - different for sprites vs meshes
                    if (objectMesh.isSprite) {
                        // Sprites use material.rotation for 2D spin
                        objectMesh.material.rotation = currentObject.rotation;
                    } else {
                        // 3D meshes use object rotation
                        objectMesh.rotation.z = currentObject.rotation;
                        objectMesh.rotation.x = currentObject.rotation * 0.5;
                    }
                }

                // Camera follows object - directly behind
                if (cameraMode === 'DUMPYARD') {
                    targetCameraPos.set(
                        currentObject.x,
                        Math.max(4, currentObject.y + 3),
                        currentObject.z - 18
                    );
                    targetCameraLook.set(currentObject.x, Math.max(0, currentObject.y - 1), currentObject.z + 15);
                } else {
                    // Viewing from grass side
                    targetCameraPos.set(
                        currentObject.x,
                        Math.max(4, currentObject.y + 3),
                        currentObject.z + 18
                    );
                    targetCameraLook.set(currentObject.x, Math.max(0, currentObject.y - 1), currentObject.z - 15);
                }

                // Check landing
                if (currentObject.y <= 0 && currentObject.vy < 0) {
                    currentObject.y = 0.5;
                    currentObject.vy = 0;
                    currentObject.vx = 0;
                    currentObject.vz = 0;
                    currentObject.rotationSpeed = 0;

                    if (objectMesh) {
                        objectMesh.position.y = 0.5;
                    }

                    const lakeStart = CONFIG.LAKE_Z - CONFIG.LAKE_WIDTH / 2;
                    const lakeEnd = CONFIG.LAKE_Z + CONFIG.LAKE_WIDTH / 2;

                    if (currentObject.z >= lakeStart && currentObject.z <= lakeEnd) {
                        playWaterSplash();
                        // Spawn fish splash animation
                        spawnFishSplash(currentObject.x, currentObject.z);
                        // Start object fade
                        objectFading = true;
                        objectFadeStart = performance.now();
                        handleSuccess();
                        return; // Exit update
                    } else if (currentObject.z < lakeStart) {
                        // Landed short - stay here, shoot toward lake
                        playThumpItem();
                        cameraMode = 'DUMPYARD';
                        trailPoints = [];
                        updateTrail();
                        setCameraBehindObject();
                        gameState = 'FLING';
                    } else if (currentObject.z > lakeEnd) {
                        // Overshot - stay here, shoot back toward lake
                        playThumpItem();
                        cameraMode = 'GRASS';
                        trailPoints = [];
                        updateTrail();
                        setCameraBehindObject();
                        gameState = 'FLING';
                    }
                }
            }
        }

        function handleSuccess() {
            const thrownWord = currentObject.word; // Store before clearing
            const objectX = currentObject.x;
            const objectY = currentObject.y;
            const objectZ = currentObject.z;

            const wordPoints = thrownWord.length * CONFIG.POINTS_PER_LETTER;
            // Score reduces by 1/3 with each shot (multiply by 2/3)
            const shotMultiplier = Math.pow(2 / 3, shotsTaken - 1);
            const earnedPoints = Math.round(wordPoints * shotMultiplier);

            score += earnedPoints;
            pilesCleared++;

            // Spawn floating score display
            floatingScore = {
                x: objectX,
                y: objectY + 1,
                z: objectZ,
                value: earnedPoints,
                startTime: performance.now()
            };

            // Mark pile as inactive (it's already fading from when item was thrown)
            if (activePileIndex >= 0 && trashPiles[activePileIndex]) {
                const pile = trashPiles[activePileIndex];
                pile.active = false;
                // Don't remove mesh here - it's fading out gracefully
            }

            // Don't remove object mesh here - it's fading into the water with fish animation

            trailPoints = [];
            updateTrail();

            const pilesLeft = trashPiles.filter(p => p.active).length;
            if (pilesLeft === 0) {
                gameState = 'TRANSITIONING';
                currentObject = null;
                activePileIndex = -1;
                setTimeout(() => {
                    gameState = 'VICTORY';
                    signalGameOver(score);
                }, 1500);
                return;
            }

            // Set state immediately to avoid race condition
            gameState = 'TRANSITIONING';
            currentObject = null;
            activePileIndex = -1;

            // Show boss dialog after successful shot
            startSuccessDialog(thrownWord);
        }

        function startSuccessDialog(itemName) {
            const successLines = [
                `Good riddance. Who needs ${itemName}.`,
                "Beauty. Keep going.",
                "Ahh, this place feels cleaner already.",
                "The best junk is junk out of my yard.",
                `${playerName}, I knew I was right to hire you.`,
                `Look at the fishes chomp on that ${itemName}!`,
                `Keep going, ${playerName}, we'll be done in no time.`,
                `${itemName}? Couldn't catch me buying that.`
            ];

            dialogActive = true;
            dialogLines = [successLines[Math.floor(Math.random() * successLines.length)]];
            currentDialogLine = 0;
            currentDialogChar = 0;
            dialogCharTimer = 0;
            dialogPauseTimer = 0;
        }

        function finishSuccessTransition() {
            generateLetterPool();
            cameraMode = 'DUMPYARD';
            targetCameraPos.set(0, 5, -10);
            targetCameraLook.set(0, 0, 50);
            gameState = 'WORD_BUILDING';
        }

        function showMessage(msg) {
            message = msg;
            messageTimer = 1500;
        }

        function setCameraBehindObject() {
            // Sets the target camera position directly behind the object (smooth transition)
            if (!currentObject) return;

            if (cameraMode === 'DUMPYARD') {
                // Directly behind object, looking toward lake
                targetCameraPos.set(currentObject.x, 5, currentObject.z - 18);
                targetCameraLook.set(currentObject.x, 1, currentObject.z + 30);
            } else {
                // Directly behind object on grass side, looking toward dumpyard
                targetCameraPos.set(currentObject.x, 5, currentObject.z + 18);
                targetCameraLook.set(currentObject.x, 1, currentObject.z - 30);
            }
        }

        // ============================================
        // GAME LOOP
        // ============================================
        function gameLoop() {
            update();
            renderer.render(scene, camera);
            renderUI();
            requestAnimationFrame(gameLoop);
        }

        function startIntroDialog() {
            dialogActive = true;
            dialogLines = [
                `Hey, ${playerName}!`,
                "We have a big problem!",
                "This dumpyard is full, and there's more trash coming!",
                "Thankfully, we've got a perfectly fine lake over there...",
                "You know what to do."
            ];
            currentDialogLine = 0;
            currentDialogChar = 0;
            dialogCharTimer = 0;
            dialogPauseTimer = 0;
        }

        function startLetterReveal() {
            // Letters are already in queue from generateLetterPool
            letterAnimationTimer = 0;
            gameState = 'LETTER_REVEAL';
        }

        function resetGame() {
            score = 0;
            pilesCleared = 0;
            shotsTaken = 0;
            currentObject = null;
            activePileIndex = -1;
            pendingPileIndex = -1;
            showDictionary = false;
            showQuitConfirm = false;
            cameraMode = 'DUMPYARD';
            hasShownShootHint = false;
            lastWordValid = false;
            gameWords = []; // Reset so new words are selected for new game
            floatingScore = null;
            objectFading = false;
            // Clean up any active fish
            for (const fish of activeFish) {
                if (fish.mesh) scene.remove(fish.mesh);
            }
            activeFish = [];

            if (objectMesh) {
                scene.remove(objectMesh);
                objectMesh = null;
            }

            trailPoints = [];
            updateTrail();

            targetCameraPos.set(0, 5, -10);
            targetCameraLook.set(0, 0, 50);
            camera.position.copy(targetCameraPos);
            camera.userData.currentLookAt = targetCameraLook.clone();
            camera.lookAt(targetCameraLook);

            createTrashPiles();
            selectGameWords(); // Pick 16 words for the whole game
            generateLetterPool(); // Set up letter tiles

            // Start intro dialog
            gameState = 'INTRO';
            startIntroDialog();
        }

        function init() {
            initThree();
            initUI();
            initInput();
            initSoundEffects();
            initRemixSDK();
            handleResize(); // Initial sizing

            // Load textures, then build environment and start game
            loadTextures(() => {
                buildEnvironment();
                resetGame();
                gameLoop();
            });
        }

        init();
    </script>
</body>

</html>